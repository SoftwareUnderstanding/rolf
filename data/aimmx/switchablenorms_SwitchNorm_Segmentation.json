{
    "visibility": {
        "visibility": "public"
    },
    "name": "Switchable Normalization for Semantic Segmentation",
    "definition": {
        "code": [
            {
                "type": "repo",
                "repo_type": "github",
                "owner": "switchablenorms",
                "owner_type": "User",
                "name": "SwitchNorm_Segmentation",
                "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation",
                "stars": 48,
                "pushed_at": "2018-10-22 17:47:07+00:00",
                "created_at": "2018-09-25 14:09:07+00:00",
                "language": "Python",
                "description": "Switchable Normalization for semantic image segmentation and scene parsing.",
                "frameworks": [
                    "PyTorch"
                ]
            },
            {
                "type": "code",
                "name": ".gitignore",
                "sha": "56b565a1b54dd1753ce3141e05ee3bc81a554456",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/.gitignore"
                    }
                },
                "size": 917
            },
            {
                "type": "code",
                "name": "dataset.py",
                "sha": "411057e830bf08b7f8c9c4817ec223a5846602ec",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/dataset.py"
                    }
                },
                "size": 12919
            },
            {
                "type": "code",
                "name": "demo_test.sh",
                "sha": "540cd906a4dd5c3021ed6ec7c841610530de6935",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/demo_test.sh"
                    }
                },
                "size": 794
            },
            {
                "type": "code",
                "name": "download_ADE20K.sh",
                "sha": "b3844632cfc560bf9e56b193087c34cef36424a3",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/download_ADE20K.sh"
                    }
                },
                "size": 221
            },
            {
                "type": "code",
                "name": "eval.py",
                "sha": "b5c1efaf68c0cf0a478591db5def935ed34eabe9",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/eval.py"
                    }
                },
                "size": 7079
            },
            {
                "type": "code",
                "name": "lib",
                "sha": "58dff31aa7b337f84cb72c0457dde2bc02ea8c49",
                "filetype": "dir",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/tree/master/lib"
                    }
                },
                "num_files": 2
            },
            {
                "type": "code",
                "name": "models",
                "sha": "b04b894617a1443c9039c043f157d81465aa9c38",
                "filetype": "dir",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/tree/master/models"
                    }
                },
                "num_files": 7
            },
            {
                "type": "code",
                "name": "pretrained_sn",
                "sha": "ca322c62aacf2547c01a5f64b3ea05b28a5736ee",
                "filetype": "dir",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/tree/master/pretrained_sn"
                    }
                },
                "num_files": 1
            },
            {
                "type": "code",
                "name": "scripts",
                "sha": "390d17954caf00fb308d4a51132ebbafa599c604",
                "filetype": "dir",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/tree/master/scripts"
                    }
                },
                "num_files": 2
            },
            {
                "type": "code",
                "name": "test.py",
                "sha": "bb18bd8eff0eee3c45f0ecf6d6f1eac59186c897",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/test.py"
                    }
                },
                "size": 5985
            },
            {
                "type": "code",
                "name": "train.py",
                "sha": "0335cec803f42f5c09663967927bd29249a621da",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/train.py"
                    }
                },
                "size": 13841
            },
            {
                "type": "code",
                "name": "utils.py",
                "sha": "ee3dd928ed8b11b389736ea5eaa1426a7488081f",
                "filetype": "file",
                "connection": {
                    "name": "github_url",
                    "source": {
                        "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation/blob/master/utils.py"
                    }
                },
                "size": 4883
            }
        ]
    },
    "authors": [
        {
            "name": "Ramon Cheung",
            "github_id": "ruixuejianfei"
        },
        {
            "name": "switchnorm",
            "github_id": "switchablenorms"
        }
    ],
    "tags": [
        "segmentation",
        "scene-parsing",
        "cityscapes",
        "ade20k",
        "convolutional-neural-networks"
    ],
    "description": "Switchable Normalization for semantic image segmentation and scene parsing.",
    "extraction": [
        {
            "type": "github",
            "url": "https://github.com/switchablenorms/SwitchNorm_Segmentation",
            "stars": 48,
            "issues": true,
            "readme": "# Switchable Normalization for Semantic Segmentation\n\n\n\nThis repository contains the code of using Swithable Normalization (SN) in semantic image segmentation, proposed by the paper \n[\"Differentiable Learning-to-Normalize via Switchable Normalization\"](https://arxiv.org/abs/1806.10779).\n\nThis is the implementations of the experiments presented in the above paper by using open-source semantic segmentation framework [Scene Parsing on MIT ADE20K](https://github.com/CSAILVision/semantic-segmentation-pytorch).\n\n## Update\n\n- 2018/9/26: The code and trained models of semantic segmentation on ADE20K by using SN are released !\n- More results and models will be released soon. \n\n## Citation\n\nYou are encouraged to cite the following paper if you use SN in research or wish to refer to the baseline results.\n\n```\n@article{SwitchableNorm,\n  title={Differentiable Learning-to-Normalize via Switchable Normalization},\n  author={Ping Luo and Jiamin Ren and Zhanglin Peng},\n  journal={arXiv:1806.10779},\n  year={2018}\n}\n```\n\n## Getting Started\n\nUse git to clone this repository:\n\n```\ngit clone https://github.com/switchablenorms/SwitchNorm_Segmentation.git\n```\n\n### Environment\n\nThe code is tested under the following configurations.\n\n- Hardware: 1-8 GPUs (with at least 12G GPU memories)\n- Software: CUDA 9.0, Python 3.6, PyTorch 0.4.0, tensorboardX\n\n### Installation & Data Preparation\n\nPlease check the [Environment](https://github.com/CSAILVision/semantic-segmentation-pytorch/blob/master/README.md#environment), [Training](https://github.com/CSAILVision/semantic-segmentation-pytorch/blob/master/README.md#training) and [Evaluation](https://github.com/CSAILVision/semantic-segmentation-pytorch/blob/master/README.md#evaluation) subsection in the repo [Scene Parsing on MIT ADE20K](https://github.com/CSAILVision/semantic-segmentation-pytorch) for a quick start.\n\n### Pre-trained Models\n\nDownload SN based ImageNet pretrained model and put them into the `{repo_root}/pretrained_sn`.\n\n#### ImageNet pre-trained models\n\nThe backbone models with SN pretrained on ImageNet are available in the format used by above Segmentation Framework and this repo.\n\n- ResNet50v1+SN(8,2)  [[pretrained_SN(8,2)](https://drive.google.com/file/d/1tHJiCZ3CBXJGiIc9b634S4Rd9KLOfr1P/view?usp=sharing)]\n\n\nFor more pretrained models with SN, please refer to the repo of [switchablenorms/Switchable-Normalization](https://github.com/switchablenorms/Switchable-Normalization).\nThe following script converts the model trained from [Switchable-Normalization](https://github.com/switchablenorms/Switchable-Normalization) into a valid format used by the semantic segmentation codebase :  `./pretrained_sn/convert_sn.py`\n\n```\nusage: python -u convert_sn.py\n```\n\n**NOTE:** The paramater keys in pretrained model checkpoint must match the keys in backbone model **EXACTLY**.  You should load the correct pretrained model according to your segmentation architechure.\n\n\n### Training\n\n- The training strategies of baseline models and sn-based models on ADE20K are same as  [Scene Parsing on MIT ADE20K](https://github.com/CSAILVision/semantic-segmentation-pytorch).\n- The training script with ResNet-50-sn backbone can be found here:  `./scripts/train.sh`\n\n**NOTE:** The default architecture of this repo is `Encoder: resnet50_dilated8 ` ( resnetXX_dilatedYY: customized resnetXX with dilated convolutions, output feature map is 1/YY of input size, see [DeepLab](https://arxiv.org/abs/1606.00915.pdf) for more details ) and `Decoder: c1_bilinear_deepsup` ( 1 conv + bilinear upsample + deep supervision, see [PSPNet](https://arxiv.org/abs/1612.01105) for more details ).\n\n\n\nOptional arguments (see full input arguments via `./train.py`):\n\n```\n  --arch_encoder         architecture of encode network\n  --arch_decoder         architecture of decode network\n  --weights_encoder      weights to finetune endoce network\n  --weights_decoder      weights to finetune decode network\n  --list_train           the list to load the training data \n  --root_dataset         the path of the dataset\n  --batch_size_per_gpu   input batch size\n  --start_epoch          epoch to start training. (continue from a checkpoint loaded via weights_encoder & weights_decoder)\n  \n```\n**NOTE:**  In this repo, `--start_epoch` allows the training to resume from the checkpoint loaded from `--weights_encoder` and `--weights_decoder`, which is generated in the training process automatically. If you want to train from scratch, you need to assign `--start_epoch` as 1 and set `--weights_encoder` and `--weights_decoder`   to the blank value.\n\n\n### Evaluation\n\n- The evaluation script with ResNet-50-sn backbone can be found here : `./scripts/evaluate.sh`\n\n\nOptional arguments (see full input arguments via `./eval.py`):\n\n```\n  --arch_encoder         architecture of encode network\n  --arch_decoder         architecture of decode network\n  --suffix               which snapshot to load\n  --list_val             the list to load the validation data \n  --root_dataset         the path of the dataset\n  --imgSize              list of input image sizes\n```\n\n`--imgSize` enables single-scale or multi-scale inference. When `--load_dir` is with the `int` type, the single-scale inference will be started up. When `--load_dir` is a `int list`,  the multi-scale test will be applied.\n\n\n## Main Results\n\n### Semantic Segmentation Results on ADE20K \n\nThe experiment results are on the ADE20K validation set. MS test is short for multi-scale test. `sync BN` indicates the mutli-GPU synchronization batch normalization. More results and models will be released soon. \n\n|     Architecture      |  Norm   |   MS test  | Mean IoU |  Pixel Acc. |  Overall Score  | Download |\n| :---:         |  :---:  |  :---:      |  :---:  |  :---:  |  :---:  |  :---:  |  \n| ResNet50_dilated8 + c1_bilinear_deepsup| sync BN | no | 36.43 | 77.30 | 56.87 | [encoder](https://drive.google.com/file/d/1T0IAGpM1qIuT_74VGfuHyQ4QzYU3j55C/view?usp=sharing)  [decoder](https://drive.google.com/file/d/1fvrmSDQb58WHbUu-Ev15kidcaf7VwaFr/view?usp=sharing)  |\n| ResNet50_dilated8 + c1_bilinear_deepsup| GN      | no | 35.66 | 77.24 | 56.45 | [encoder](https://drive.google.com/file/d/1YoXrwvfYzsHQ4P3IyVF2iThWzQtaTbGR/view?usp=sharing)  [decoder](https://drive.google.com/file/d/1HbuyhIiS3fPvBnHYG5xFRwj5Gpv5ULzT/view?usp=sharing)\n| ResNet50_dilated8 + c1_bilinear_deepsup| SN-(8,2)| no | 38.72 | 78.90 | 58.82 | [encoder](https://drive.google.com/file/d/1Dn15_QTjdzX1pK3nvXHnHy94V7ffcKjL/view?usp=sharing)   [decoder](https://drive.google.com/file/d/1wS0lV9hWIBwWQ-Bhvdc1IRFyw3O_Fegx/view?usp=sharing) |\n|||||\n| ResNet50_dilated8 + c1_bilinear_deepsup| sync BN | yes | 37.69 | 78.29 | 57.99 | -- |\n| ResNet50_dilated8 + c1_bilinear_deepsup| GN      | yes | 36.32 | 77.77 | 57.05 | -- |\n| ResNet50_dilated8 + c1_bilinear_deepsup| SN-(8,2)| yes | 39.21 | 79.20 | 59.21 | -- |\n\n\n**NOTE:** For all settings in this repo, we employ ResNet as the backbone network, using the original 7\u00d77 kernel size in the first convolution layer. This is different from the [MIT framework](https://github.com/CSAILVision/semantic-segmentation-pytorch) , which adopts 3 convolution layers with the kernel size 3\u00d73 at the bottom of the network. See  `./models/resnet_v1_sn.py` for the details.\n\n",
            "readme_url": "https://github.com/switchablenorms/SwitchNorm_Segmentation",
            "frameworks": [
                "PyTorch"
            ]
        }
    ],
    "references": [
        {
            "title": "Differentiable Learning-to-Normalize via Switchable Normalization",
            "arxiv": "1806.10779",
            "year": 2018,
            "url": "http://arxiv.org/abs/1806.10779v5",
            "abstract": "We address a learning-to-normalize problem by proposing Switchable\nNormalization (SN), which learns to select different normalizers for different\nnormalization layers of a deep neural network. SN employs three distinct scopes\nto compute statistics (means and variances) including a channel, a layer, and a\nminibatch. SN switches between them by learning their importance weights in an\nend-to-end manner. It has several good properties. First, it adapts to various\nnetwork architectures and tasks (see Fig.1). Second, it is robust to a wide\nrange of batch sizes, maintaining high performance even when small minibatch is\npresented (e.g. 2 images/GPU). Third, SN does not have sensitive\nhyper-parameter, unlike group normalization that searches the number of groups\nas a hyper-parameter. Without bells and whistles, SN outperforms its\ncounterparts on various challenging benchmarks, such as ImageNet, COCO,\nCityScapes, ADE20K, and Kinetics. Analyses of SN are also presented. We hope SN\nwill help ease the usage and understand the normalization techniques in deep\nlearning. The code of SN has been made available in\nhttps://github.com/switchablenorms/.",
            "authors": [
                "Ping Luo",
                "Jiamin Ren",
                "Zhanglin Peng",
                "Ruimao Zhang",
                "Jingyu Li"
            ]
        },
        {
            "title": "Pyramid Scene Parsing Network",
            "arxiv": "1612.01105",
            "year": 2016,
            "url": "http://arxiv.org/abs/1612.01105v2",
            "abstract": "Scene parsing is challenging for unrestricted open vocabulary and diverse\nscenes. In this paper, we exploit the capability of global context information\nby different-region-based context aggregation through our pyramid pooling\nmodule together with the proposed pyramid scene parsing network (PSPNet). Our\nglobal prior representation is effective to produce good quality results on the\nscene parsing task, while PSPNet provides a superior framework for pixel-level\nprediction tasks. The proposed approach achieves state-of-the-art performance\non various datasets. It came first in ImageNet scene parsing challenge 2016,\nPASCAL VOC 2012 benchmark and Cityscapes benchmark. A single PSPNet yields new\nrecord of mIoU accuracy 85.4% on PASCAL VOC 2012 and accuracy 80.2% on\nCityscapes.",
            "authors": [
                "Hengshuang Zhao",
                "Jianping Shi",
                "Xiaojuan Qi",
                "Xiaogang Wang",
                "Jiaya Jia"
            ]
        },
        {
            "title": "DeepLab: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFs",
            "arxiv": "1606.00915",
            "year": 2016,
            "url": "http://arxiv.org/abs/1606.00915v2",
            "abstract": "In this work we address the task of semantic image segmentation with Deep\nLearning and make three main contributions that are experimentally shown to\nhave substantial practical merit. First, we highlight convolution with\nupsampled filters, or 'atrous convolution', as a powerful tool in dense\nprediction tasks. Atrous convolution allows us to explicitly control the\nresolution at which feature responses are computed within Deep Convolutional\nNeural Networks. It also allows us to effectively enlarge the field of view of\nfilters to incorporate larger context without increasing the number of\nparameters or the amount of computation. Second, we propose atrous spatial\npyramid pooling (ASPP) to robustly segment objects at multiple scales. ASPP\nprobes an incoming convolutional feature layer with filters at multiple\nsampling rates and effective fields-of-views, thus capturing objects as well as\nimage context at multiple scales. Third, we improve the localization of object\nboundaries by combining methods from DCNNs and probabilistic graphical models.\nThe commonly deployed combination of max-pooling and downsampling in DCNNs\nachieves invariance but has a toll on localization accuracy. We overcome this\nby combining the responses at the final DCNN layer with a fully connected\nConditional Random Field (CRF), which is shown both qualitatively and\nquantitatively to improve localization performance. Our proposed \"DeepLab\"\nsystem sets the new state-of-art at the PASCAL VOC-2012 semantic image\nsegmentation task, reaching 79.7% mIOU in the test set, and advances the\nresults on three other datasets: PASCAL-Context, PASCAL-Person-Part, and\nCityscapes. All of our code is made publicly available online.",
            "authors": [
                "Liang-Chieh Chen",
                "George Papandreou",
                "Iasonas Kokkinos",
                "Kevin Murphy",
                "Alan L. Yuille"
            ]
        }
    ],
    "training": {
        "datasets": [
            {
                "name": "ADE20K"
            },
            {
                "name": "ImageNet"
            },
            {
                "name": "Cityscapes"
            },
            {
                "name": "PASCAL-Person-Part"
            },
            {
                "name": "COCO"
            },
            {
                "name": "PASCAL VOC 2012"
            }
        ]
    },
    "domain": {
        "domain_type": "Computer Vision",
        "domain_prob": 0.999890971516943,
        "task": "Semantic Segmentation",
        "task_prob": 0.9728917396447684
    }
}