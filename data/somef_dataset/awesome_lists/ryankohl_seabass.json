{
  "codeRepository": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/ryankohl/seabass",
    "technique": "GitHub API"
  },
  "dateCreated": {
    "confidence": [
      1.0
    ],
    "excerpt": "2011-04-15T17:03:56Z",
    "technique": "GitHub API"
  },
  "dateModified": {
    "confidence": [
      1.0
    ],
    "excerpt": "2019-02-27T15:40:10Z",
    "technique": "GitHub API"
  },
  "description": [
    {
      "confidence": [
        0.9891033400885054
      ],
      "excerpt": "This is a small library to make it easier to work with RDF and SPARQL in Clojure 1.4.  Uploaded to Clojars at http://clojars.org/seabass \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8337152154660451
      ],
      "excerpt": "Takes n-many arguments and returns an RDF model.  These arguments can be \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9013766304612584
      ],
      "excerpt": "Strings for URI's that resolve to an RDF file online \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9187604169110972
      ],
      "excerpt": "  second element is the language (when the file suffix isn't sufficient). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877,
        0.9190093140122509
      ],
      "excerpt": "A Jena model \nThis executes a SELECT query against an RDF model, returning a map with  \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9168794097784424,
        0.9832123358188667,
        0.8351783621152147
      ],
      "excerpt": "- :vars - the list of variables used in the select query's 'projection' clause \n- :data - a list of maps whose keys are the variables listed in :vars \nThe arguments are: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9288830337815963
      ],
      "excerpt": "target: either a URI string for a Sparql Endpoint or an RDF model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9288830337815963
      ],
      "excerpt": "target: either a URI string for a Sparql Endpoint or an RDF model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9527401612400435
      ],
      "excerpt": "new RDF model.  The arguments are: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9288830337815963,
        0.9307939207381238,
        0.8886658427294921
      ],
      "excerpt": "target: either a URI string for a Sparql Endpoint or an RDF model \nWrites the contents of a model to the file specified by the target string. \nThe resulting file is encoded in n-triples.  Only RDF facts are written  \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8331955998185947,
        0.8175016469553605,
        0.9606129676712364,
        0.9796235604028144,
        0.879085388630007,
        0.8175016469553605,
        0.9606129676712364,
        0.9796235604028144
      ],
      "excerpt": "target: a string for a relative or absolute pathname for the file to write to \nThese functions return Jena triples, which can be pushed into a model. \nsubject: A string that is a valid uri or a string starting with '_:', indicating a blank node \npredicate: A string that is a valid uri \nobject: A string that is a valid uri, or a string starting with '_:', indicating a blank node.  Will be interpreted as an RDF resource. \nThese functions return Jena triples, which can be pushed into a model. \nsubject: A string that is a valid uri or a string starting with '_:', indicating a blank node \npredicate: A string that is a valid uri \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.95606047611482,
        0.9517302404481846
      ],
      "excerpt": "Asserts a collection of  triples into the target, which can either be a Jena model or a remote endpoint uri string. \nAll built-ins supported in Jena 2.9.2 (the current release as of April, 2011) can be used.  The following built-ins have been added for Jena Rules (i.e. in .rules files, and not in Sparql queries): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        1.0
      ],
      "excerpt": "A library for working with RDF with Jena in Clojure (http://clojars.org/seabass)",
      "technique": "GitHub API"
    }
  ],
  "downloadUrl": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/ryankohl/seabass/releases",
    "technique": "GitHub API"
  },
  "forks_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 2,
      "date": "Mon, 20 Dec 2021 16:37:33 GMT"
    },
    "technique": "GitHub API"
  },
  "forks_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/ryankohl/seabass/forks",
    "technique": "GitHub API"
  },
  "fullName": {
    "confidence": [
      1.0
    ],
    "excerpt": "ryankohl/seabass",
    "technique": "GitHub API"
  },
  "installation": [
    {
      "confidence": [
        0.9045492392588854
      ],
      "excerpt": "Add the following line to your dependencies: \n",
      "technique": "Supervised classification"
    }
  ],
  "invocation": [
    {
      "confidence": [
        0.8270467157655474
      ],
      "excerpt": "value.  The arguments are: \n",
      "technique": "Supervised classification"
    }
  ],
  "issueTracker": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/ryankohl/seabass/issues{/number}",
    "technique": "GitHub API"
  },
  "languages": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "Clojure"
    ],
    "technique": "GitHub API"
  },
  "license": {
    "confidence": [
      1.0
    ],
    "technique": "GitHub API"
  },
  "long_title": {
    "confidence": [
      1.0
    ],
    "excerpt": "seabass\n----\n\nThis is a small library to make it easier to work with RDF and SPARQL in Clojure 1.4.  Uploaded to Clojars at http://clojars.org/seabass\n\nLeiningen\n----\n\nAdd the following line to your dependencies:\n\n```clj\n[seabass \"2.1.1\"]\n```\n\nDefault Prefixes\n----\n\n- xsd  (http://www.w3.org/2001/XMLSchema#)\n- rdf  (http://www.w3.org/1999/02/22-rdf-syntax-ns#)\n- rdfs (http://www.w3.org/2000/01/rdf-schema#)\n- owl  (http://www.w3.org/2002/07/owl#)\n\nAPI\n----\n\nbuild [ & targets ]",
    "technique": "Regular expression"
  },
  "name": {
    "confidence": [
      1.0
    ],
    "excerpt": "seabass",
    "technique": "GitHub API"
  },
  "owner": {
    "confidence": [
      1.0
    ],
    "excerpt": "ryankohl",
    "technique": "GitHub API"
  },
  "ownerType": {
    "confidence": [
      1.0
    ],
    "excerpt": "User",
    "technique": "GitHub API"
  },
  "readme_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/ryankohl/seabass/blob/master/readme.markdown",
    "technique": "GitHub API"
  },
  "stargazers_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 27,
      "date": "Mon, 20 Dec 2021 16:37:33 GMT"
    },
    "technique": "GitHub API"
  },
  "usage": [
    {
      "confidence": [
        1
      ],
      "excerpt": "-   Build an RDF model with a local TTL file, a remote NT file, and a model pulled from an Endpoint\n\n```clj\n(def c \"construct {?x <http://seabass.foo/bar> ?y}\n\t{ ?y <http://example.org/baz> ?x }\")\n(def m (build [\"data/my-ontology.rdf\" \"TTL\"] \n       \"http://way.out.there/my-data.nt\" \n       (pull c \"http://my-endpoint/sparql\")))\n```\n\n- Push three facts into a locally-hosted Sesame repo called 'test'\n\n```clj\n(def endpoint \"http://localhost:8080/openrdf-sesame/repositories/test/statements\")\n(def r1 (resource-fact \"http://foo/luke\" \"http://foo/sibling\" \"http://foo/leia\"))\n(def r2 (resource-fact \"_:v\" \"http://foo/father\" \"http://foo/luke\"))\n(def l1 (literal-fact \"_:v\" \"http://foo/wears\" \"http://foo/cape\"))\n(push endpoint [r1 r2 l1])\n```\n\t\n-   Ask whether a Sparql endpoint is up\n\n```clj\n(ask \"ask {}\" \"http://my-endpoint/sparql\")\n```\n\t\n-   Execute a Select query\n\n```clj\n(def q \"select ?x ?y ?z \n        {?x <http://ex.org/foo> ?y . \n         ?z <http://ex.org/bar ?y . }\")\n(def m  (build \"data/my-ont.ttl\" \"data/your-ont.owl\"))\n(bounce q m)\n```\n\n\n\n",
      "technique": "Header extraction"
    }
  ]
}