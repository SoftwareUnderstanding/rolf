{
  "arxivLinks": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://arxiv.org/abs/1803.05407",
      "https://arxiv.org/abs/1612.01474",
      "https://arxiv.org/abs/1906.02691",
      "https://arxiv.org/abs/1511.02222"
    ],
    "technique": "Regular expression"
  },
  "citation": [
    {
      "confidence": [
        0.9637972898657811
      ],
      "excerpt": "  <img src=\"misc/logo_rectan.png\" width=\"80%\" title=\"AtomAI\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9983185333282012,
        0.9254182862386431,
        0.9987127781219163
      ],
      "excerpt": "Exploring order parameters and dynamic processes in disordered systems via variational autoencoders. Science Advances 7, eabd5084 (2021). doi:10.1126/sciadv.abd5084 \nDisentangling Rotational Dynamics and Ordering Transitions in a System of Self-Organizing Protein Nanorods via Rotationally Invariant Latent Representations. ACS Nano (2021). doi:10.1021/acsnano.0c08914 \nTracking atomic structure evolution during directed electron beam induced Si-atom motion in graphene via deep machine learning. Nanotechnology 32, 035703 (2020). doi:10.1088/1361-6528/abb8a6 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8955886365383559
      ],
      "excerpt": "input_dim = (32, 32) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8109194328925066
      ],
      "excerpt": "    ConvBlock(2, 2, 32, 64, batch_norm=False) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8109194328925066,
        0.8444342525991423
      ],
      "excerpt": "    ConvBlock(2, 2, 64, 32, batch_norm=False), \n    UpsampleBlock(2, 32, 32, mode=\"nearest\"), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8550101043698384
      ],
      "excerpt": "components, imgs, coords = imstack.gmm(n_components=10, plot_results=True) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9848179726092176
      ],
      "excerpt": "transitions_dict = imstack.transition_matrix(n_components=10, rmax=10) \n",
      "technique": "Supervised classification"
    }
  ],
  "codeRepository": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/pycroscopy/atomai",
    "technique": "GitHub API"
  },
  "dateCreated": {
    "confidence": [
      1.0
    ],
    "excerpt": "2020-09-04T06:08:25Z",
    "technique": "GitHub API"
  },
  "dateModified": {
    "confidence": [
      1.0
    ],
    "excerpt": "2021-12-07T18:44:25Z",
    "technique": "GitHub API"
  },
  "description": [
    {
      "confidence": [
        0.9945888852492858
      ],
      "excerpt": "AtomAI is a Pytorch-based package for deep/machine learning analysis of microscopy data, which doesn't require any advanced knowledge of Python or machine learning. The intended audience is domain scientists with basic knowledge of how to use NumPy and Matplotlib. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9995723992629251
      ],
      "excerpt": "The purpose of the AtomAI is to provide an environment that bridges the instrument specific libraries and general physical analysis by enabling the seamless deployment of machine learning algorithms including deep convolutional neural networks, invariant variational autoencoders, and decomposition/unmixing techniques for image and hyperspectral data analysis. Ultimately, it aims to combine the power and flexibility of the PyTorch deep learning framework and simplicity and intuitive nature of packages such as scikit-learn, with a focus on scientific data. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.972827974550461,
        0.9000493366658272
      ],
      "excerpt": "Have some specific questions about applications of deep/machine learning (DL/ML) in microscopy? Feel free to ask them on Gitter! \nThe easiest way to start using AtomAI is via Google Colab:  \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9614361141897869
      ],
      "excerpt": "Defect sniffer: Deep Learning and Graph Analysis to Locate Specific Types of Defects \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9677346353766828
      ],
      "excerpt": "Implementation of Custom Image Denoiser in AtomAI \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9713511585209869
      ],
      "excerpt": "If your goal is to train and/or apply deep learning models for semantic segmentation of your experimental images, it is recommended to start with atomai.models.Segmentor, which provides an easy way to train neural networks (with just two lines of code) and to make a prediction with trained models (with just one line of code). Here is an example of how one can train a neural network for atom/particle/defect finding with essentially two lines of code: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877,
        0.8012604432419791
      ],
      "excerpt": ": Initialize model \nmodel = aoi.models.Segmentor(nb_classes=3)  #: uses UNet by default \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8227457231204905
      ],
      "excerpt": "Hereswastands for [stochastic weight averaging](https://arxiv.org/abs/1803.05407), which usually allows improving the model's accuracy and leads to better generalization. The trained model can be used to find atoms/particles/defects in new, previously unseen (by a model) data:python \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9886178378212173
      ],
      "excerpt": "AtomAI also provides models that can be used for predicting spectra from image data and vice versa. These models can be used for predicting property (functionality) from structure. An example can be predicting approximate scanning tulleling spectroscopy or electron energy loss spectroscopy spectra from structural images of local sample regions (the assumption is of course that there is only a small variability of spectral behaviour within each  (sub)-image). The training/prediction routines are very similar to those of the semantic segmentation model, with the main difference being that one has to specify the dimensions of input and output \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9927207084043193
      ],
      "excerpt": "One can also use AtomAI to train an ensemble of models instead of just a single model. The average ensemble prediction is usually more accurate and reliable than that of the single model. In addition, we also get the information about the uncertainty in our prediction for each pixel/point. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8023333781732206
      ],
      "excerpt": ": Train ensemble of 10 models starting every time with new randomly initialized weights \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8337151003654883
      ],
      "excerpt": "The ensemble of models can be then used to make a prediction with uncertainty estimates for each point (e.g. each pixel in the image): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9745275513965648
      ],
      "excerpt": "AtomAI has built-in variational autoencoders (VAEs) for finding in the unsupervised fashion the most effective reduced representation of system's local descriptors. The available VAEs are regular VAE, rotationally and/or translationally invariant VAE (rVAE), class-conditined VAE/rVAE, and joint VAE/rVAE. The VAEs can be applied to both raw data and NN output, but typically work better with the latter. Here's a simple example: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9209959170951971
      ],
      "excerpt": ": Get a stack of subimages from experimental data (e.g. a semantically segmented atomic movie) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": ": Intitialize rVAE model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8817723116639472
      ],
      "excerpt": "One can also use the trained VAE to view the data distribution in the latent space. In this example the first 3 latent variables are associated with rotations and xy-translations (they are automatically added in rVAE to whatever number of latent dimensions is specified), whereas the last 2 latent variables are associated with images content.python \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9958771278514879
      ],
      "excerpt": "AtomAI has an easy-to-use deep kernel learning module for performing automated experiments. The DKL, originally introduced by Andrew Gordon Wilson, can be understood as a hybrid of classical deep neural network (DNN) and Gaussian process (GP). The DNN serves as a feature extractor that allows reducing the complex high-dimensional features to low-dimensional descriptors on which a standard GP kernel operates. The parameters of DNN and of GP kernel are optimized jointly by performing a gradient ascent on marginal log-likelihood. Practically, the DKL training inputs are a small number of patches from an easy-to-acquire structural image (e.g., topography in STM), and training targets are usually a physical property (e.g. size of superconducting gap) derived from the spectra measured in those patches. The DKL output on the new inputs (image patches for which there are no measured spectra) is the expected property value and associated uncertainty, which are used to derive the next measurement point. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8635822844176727
      ],
      "excerpt": "    #: Select the next point to measure (assumes a discrete grid of points) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9822821963837645
      ],
      "excerpt": "Finally, it is possible to use AtomAI trainers and predictors for easy work with custom PyTorch models. Suppose we define a custom denoising autoencoder in Pytorch as \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9904480113090066
      ],
      "excerpt": ": Initialize trainer and pass our model to it \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8691104974846261
      ],
      "excerpt": ": Fix the initialization parameters (for reproducibility) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.811321501179611
      ],
      "excerpt": "The trained model can be used to make predictions on new data using AtomAI's predictors:python \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9765960846918277
      ],
      "excerpt": "The information extracted by deep neural networks can be further used for statistical analysis of raw and \"decoded\" data. For example, for a single atom-resolved image of ferroelectric material, one can identify domains with different ferroic distortions: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8200324909624754
      ],
      "excerpt": ": Get local descriptors \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8485613272868586
      ],
      "excerpt": "For movies, one can extract trajectories of individual defects and calculate the transition probabilities between different classes: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8369362092290646
      ],
      "excerpt": ": Get local descriptors (such as subimages centered around impurities) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8841614818604572
      ],
      "excerpt": ": Calculate GMM components and transition probabilities for different trajectories \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9539756471316176
      ],
      "excerpt": ": and more \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        1.0
      ],
      "excerpt": "Deep and Machine Learning for Microscopy",
      "technique": "GitHub API"
    }
  ],
  "documentation": [
    {
      "confidence": [
        1.0
      ],
      "excerpt": "https://atomai.readthedocs.io/",
      "technique": "Regular expression"
    }
  ],
  "downloadUrl": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/pycroscopy/atomai/releases",
    "technique": "GitHub API"
  },
  "forks_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 15,
      "date": "Wed, 29 Dec 2021 05:07:59 GMT"
    },
    "technique": "GitHub API"
  },
  "forks_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/pycroscopy/atomai/forks",
    "technique": "GitHub API"
  },
  "fullName": {
    "confidence": [
      1.0
    ],
    "excerpt": "pycroscopy/atomai",
    "technique": "GitHub API"
  },
  "hasDocumentation": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://github.com/pycroscopy/atomai/tree/master/docs"
    ],
    "technique": "File Exploration"
  },
  "hasExecutableNotebook": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/rVAE_graphene.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/atomai_rVAE_digits.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/GraphAnalysis.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/AtomicSemanticSegmention.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/atomai_training_data.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/Cards_jrVAE_v2a.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/atomai_custom_model.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/ImSpec.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/atomai_datasets.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/Quickstart_AtomAI_in_the_Cloud.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/atomai_dkl_plasmons.ipynb",
      "https://raw.githubusercontent.com/pycroscopy/atomai/master/examples/notebooks/atomai_dkl_ferroic.ipynb"
    ],
    "technique": "File Exploration"
  },
  "installation": [
    {
      "confidence": [
        1
      ],
      "excerpt": "First, install [PyTorch](https://pytorch.org/get-started/locally/). Then, install AtomAI via\n\n```bash\npip install atomai\n```\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        0.8516685309054747
      ],
      "excerpt": ": Compile trainer \n",
      "technique": "Supervised classification"
    }
  ],
  "invocation": [
    {
      "confidence": [
        0.8196904668645076
      ],
      "excerpt": "More examples -> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9012248701992861
      ],
      "excerpt": "import atomai as aoi \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8589534893990137,
        0.8721267154501348,
        0.8837548113404653
      ],
      "excerpt": ": Train \nmodel.fit(images, labels, images_test, labels_test, #: training data (numpy arrays) \n          training_cycles=300, compute_accuracy=True, swa=True #: training parameters \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.885759511993905
      ],
      "excerpt": "nn_output, coordinates = model.predict(expdata) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.846081446015455,
        0.8449463177825133,
        0.8834732490921343,
        0.8737738160266435
      ],
      "excerpt": ": Initialize and train model \nmodel = aoi.models.ImSpec(in_dim, out_dim, latent_dim=10) \nmodel.fit(imgs_train, spectra_train, imgs_test, spectra_test,  #: training data (numpy arrays) \n       full_epoch=True, training_cycles=120, swa=True  #: training parameters \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8535132490502623
      ],
      "excerpt": "prediction = model.predict(imgs_val, norm=False) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8594142235991984
      ],
      "excerpt": "etrainer.compile_ensemble_trainer(training_cycles=500, compute_accuracy=True, swa=True) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8213380337316241
      ],
      "excerpt": "nn_out_mean, nn_out_var = predictor.predict(expdata) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8589534893990137
      ],
      "excerpt": ": Train \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8814064300474782,
        0.8079704324688302
      ],
      "excerpt": "    rotation_prior=np.pi/3, training_cycles=100, \n    batch_size=100) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8538636282028114
      ],
      "excerpt": "    #: Select the next point to measure (assumes a discrete grid of points) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8668937975765546,
        0.8300790692696723
      ],
      "excerpt": "    (imgdata_noisy, imgdata, imgdata_noisy_test, imgdata_test), #: training data \n    loss=\"mse\", training_cycles=500, swa=True  #: training parameters \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8589534893990137
      ],
      "excerpt": ": Train \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8594142235991984
      ],
      "excerpt": "p = aoi.predictors.BasePredictor(trained_model, use_gpu=True) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8594142235991984
      ],
      "excerpt": "pca_results = imstack.imblock_pca(n_components=4, plot_results=True) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.81117604616579
      ],
      "excerpt": "components, imgs, coords = imstack.gmm(n_components=10, plot_results=True) \n",
      "technique": "Supervised classification"
    }
  ],
  "issueTracker": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/pycroscopy/atomai/issues{/number}",
    "technique": "GitHub API"
  },
  "languages": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "Python"
    ],
    "technique": "GitHub API"
  },
  "license": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "name": "MIT License",
      "url": "https://api.github.com/licenses/mit"
    },
    "technique": "GitHub API"
  },
  "licenseText": {
    "confidence": [
      1.0
    ],
    "excerpt": "b'MIT License\\n\\nCopyright (c) 2020 Maxim Ziatdinov\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \"Software\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n'",
    "technique": "File Exploration"
  },
  "long_title": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/pycroscopy/atomai)",
    "technique": "Regular expression"
  },
  "name": {
    "confidence": [
      1.0
    ],
    "excerpt": "atomai",
    "technique": "GitHub API"
  },
  "owner": {
    "confidence": [
      1.0
    ],
    "excerpt": "pycroscopy",
    "technique": "GitHub API"
  },
  "ownerType": {
    "confidence": [
      1.0
    ],
    "excerpt": "Organization",
    "technique": "GitHub API"
  },
  "readme_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/pycroscopy/atomai/blob/master/README.md",
    "technique": "GitHub API"
  },
  "releases": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "- Ensemble deep kernel learning (DKL) as an 'approximation' to the fully Bayesian DKL\r\n- Thompson sampler for active learning now comes as a built-in method in the DKL class\r\n- Option to select between correlated and independent outputs for vector-valued function in DKL\r\n\r\nExample of using an ensemble of DKL models:\r\n```python\r\n# Initialize and train ensemble of models\r\ndklgp = aoi.models.dklGPR(indim=X_train.shape[-1], embedim=2)\r\ndklgp.fit_ensemble(X_train, y_train, n_models=5, training_cycles=1500, lr=0.01)\r\n# Make a prediction\r\ny_samples = dklgp.sample_from_posterior(X_test, num_samples=1000) # n_models x n_samples x n_data\r\ny_pred = y_samples.mean(axis=(0,1)) # average over model and sample dimensions\r\ny_var = y_samples.var(axis=(0,1))\r\n```\r\n\r\nExample of using a built-in Thompson sampler for active learning:\r\n```python\r\nfor e in range(exploration_steps):\r\n    # obtain/update DKL-GP posterior\r\n    dklgp = aoi.models.dklGPR(data_dim, embedim=2, precision=\"single\")\r\n    dklgp.fit(X_train, y_train, training_cycles=50)\r\n    # Thompson sampling for selecting the next measurement/evaluation point\r\n    obj, next_point = dklgp.thompson(X_cand)\r\n    # Perform a 'measurement'\r\n    y_measured = measure(next_point)\r\n    # Update measured and candidate points, etc...\r\n```",
        "dateCreated": "2021-09-06T03:08:13Z",
        "datePublished": "2021-09-06T03:13:13Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.7.3",
        "name": "v0.7.3",
        "tag_name": "v0.7.3",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.7.3",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/49044905",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.7.3"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "Bug fixes and additional utility functions for image and spectral data processing",
        "dateCreated": "2021-07-01T23:50:22Z",
        "datePublished": "2021-07-02T00:33:35Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.7.2",
        "name": "v0.7.2",
        "tag_name": "v0.7.2",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.7.2",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/45594271",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.7.2"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "Minor release to patch some numerical stability issues with DKL-GP",
        "dateCreated": "2021-06-18T09:14:06Z",
        "datePublished": "2021-06-18T09:15:28Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.7.1",
        "name": "v0.7.1",
        "tag_name": "v0.7.1",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.7.1",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/44852491",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.7.1"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "## New functionalities\r\n#### 1) Deep kernel learning (DKL)-based Gaussian process (GP) regression.\r\nThe DKL-GP is based on [this paper](https://arxiv.org/abs/1511.02222) and can be used for predicting a functional property (or properties) from structural data such as images. Example of usage:\r\n```python3\r\n# Structural image data\r\nn, d1, d2 = imgstack.shape\r\nx_train = imgstack.reshape(n, d1*d2)\r\n# Property\r\ny_train = P[:, 0] # can be a scalar or vector variable\r\n\r\n# Input data dims\r\ndata_dim = x_train.shape[-1]\r\n# Initialize model\r\ndklgp = aoi.models.dklGPR(data_dim)\r\n# Train\r\ndklgp.fit(\r\n    x_train y_train, # inputs and outputs\r\n    training_cycles=100, precision=\"single\", lr=1e-2  # training parameters\r\n)\r\n\r\n# Make a prediction (with quantified uncertainty) with the trained model\r\nmean, var = dklgp.predict(x_new)\r\n```\r\n\r\nFor more details, see the example [notebook](https://colab.research.google.com/github/pycroscopy/atomai/blob/master/examples/notebooks/atomai_dkl_ferroic.ipynb)\r\n\r\n#### 2) Pre-trained models\r\nOne can now load pre-trained models for atomic feature finding in graphene and BFO-like systems. Currently limited to STEM data. Example of usage:\r\n```python\r\n# Load model for atom finding in graphene, which was trained on simulated data\r\nmodel = aoi.models.load_pretrained_model(\"G_MD\")\r\n# Apply to your data\r\nnn_out, coords = model.predict(new_data)\r\n```\r\n\r\nAs with any machine learning model, there is a caveat that the performance of pre-trained models will likely degrade significantly on the [out-of-distribution](https://arxiv.org/pdf/2007.01434.pdf) data (different feature size, presence of objects on the surface not accounted for in the simulations, etc.)\r\n\r\n## Bug fixes\r\n- The extractor of image patches now checks for NaNs in the cropped data.",
        "dateCreated": "2021-06-17T22:36:50Z",
        "datePublished": "2021-06-17T23:06:34Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.7.0",
        "name": "v0.7.0",
        "tag_name": "v0.7.0",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.7.0",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/44833901",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.7.0"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "- Add ```atomai.utils.dataset``` module with experimental datasets for scientific machine learning\r\n- Minor bug fixes and documentation improvement",
        "dateCreated": "2021-06-01T01:40:13Z",
        "datePublished": "2021-06-01T01:40:47Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.6.8",
        "name": "v0.6.8",
        "tag_name": "v0.6.8",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.6.8",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/43879590",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.6.8"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "## New functionalities\r\n- Utility functions for converting Segmentor output (coordinates and classes) to files readable by packages such as Atomic Simulation Environment, VESTA, etc. \r\n- Optional time-dependent learning rate. For example,\r\n```python\r\n# We are going to start with a constant learning rate, then after 600 iterations we begin\r\n# linearly decreasing it over the next 200 iterations, and keep constant afterwards\r\nlr_t = np.ones(800) * 1e-3\r\nlr_t[600:800] = np.linspace(1e-3, 1e-4, 200)\r\n\r\nmodel.fit(images, labels, images_test, labels_test,  # training data\r\n          training_cycles=1000, compute_accuracy=True,  # basic training parameters\r\n          swa=True, lr_scheduler=lr_t  # advanced training parameters\r\n)\r\n```\r\n\r\n## Other changes\r\n- Added new examples (Graph analysis and Im2Spec) and expanded explanations in the markdown parts for the old ones\r\n- Improved (slightly) documentation",
        "dateCreated": "2021-05-14T01:27:11Z",
        "datePublished": "2021-05-14T01:27:28Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.6.7",
        "name": "v0.6.7",
        "tag_name": "v0.6.7",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.6.7",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/42935272",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.6.7"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "## New functionality\r\n- Added option for controlled information capacity increase to VAE and rVAE (jVAE and jrVAE have them by default). Based on Eq (8) in https://arxiv.org/pdf/1804.03599.pdf\r\n\r\n## Bug fixes\r\n- Fixed bug that was preventing from loading (older) AtomAI models without saved optimizer in their meta-dictionary\r\n\r\n## Other\r\n- Fixed some inconsistencies in classes/methods documentation\r\n- Tested against the newest PyTorch release (1.8.0) ",
        "dateCreated": "2021-03-11T02:07:55Z",
        "datePublished": "2021-03-11T02:14:37Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.6.6",
        "name": "v0.6.6",
        "tag_name": "v0.6.6",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.6.6",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/39628954",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.6.6"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "## New functionalities:\r\n- Add VAE that can learn (simultaneously) both discrete and continuous latent representations\r\n![image](https://user-images.githubusercontent.com/34245227/109348476-905b2880-7842-11eb-8f50-b9cca334e942.png)\r\n- Add option for annealing of the KL terms associated with rotation and image content to rVAE\r\n\r\n## Bug fixes\r\n- Fix bug that prevented rVAE from working in non-square images\r\n- Fix bug that was causing VAE decoders to \"forget\" apply sigmoid in evaluation regime after training with BCE with logits\r\n\r\n## Other improvements\r\n- Add option to set custom encoder and decoder modules in all VAEs\r\n- Add a substantial amount of tests for VI trainer and VAE modules\r\n- Update docs\r\n",
        "dateCreated": "2021-02-26T19:38:44Z",
        "datePublished": "2021-02-26T20:01:02Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.6.5",
        "name": "v0.6.5",
        "tag_name": "v0.6.5",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.6.5",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/38819471",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.6.5"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "## New functionalities:\r\n- ResHedNet model for advanced edge detection. This model is based on the holistically-nested edge detection [paper](https://ieeexplore.ieee.org/document/7410521). We improved the original model by replacing vanilla convolutional layers with ResNet-like blocks in each segment and by reducing the number of max-pooling operations to 2 (we found that 3 different scales are enough for learning the relevant features in typical microscopy images)\r\n- SegResNet model for general semantic segmentation as an alternative to default UNet model. It has ResNet-like connections in each segment in addition to UNet-like skip connections between encoding and decoding paths.\r\n## Bug fixes:\r\n- Fix bug that was preventing from saving/loading custom models\r\n- Fix bug that was performing a zoom-in operation even when set to False during data augmentation\r\n- Fix bug in the output_shape in BasePredictor, which required the output shape to be identical to the input shape\r\n## Improvements:\r\n- Add option to pass a custom loss function to trainers for semantic segmentation and im2spec/spec2im\r\n- Add option to store all training data on CPU when the size of the training data exceeds a certain limit (default limit is 4GB). In this case, only the individual batches are moved to a GPU device at training/test steps.\r\n- Make computation of coordinates optional for SegPredictor\r\n- Automatically save VAE models after each training cycle (\"epoch\") and not just at the end of training\r\n## New examples:\r\n- New [notebook](https://colab.research.google.com/github/pycroscopy/atomai/blob/master/examples/notebooks/atomai_custom_model.ipynb) on constructing and using (training+predicting) a custom image denoiser with AtomAI\r\n- New [notebook](https://colab.research.google.com/github/pycroscopy/atomai/blob/master/examples/notebooks/atomai_rVAE_digits.ipynb) on applications of rotationally invariant VAE (rVAE)  and class-conditioned rVAE to arbitrary rotated handwritten digits",
        "dateCreated": "2020-12-29T22:50:53Z",
        "datePublished": "2020-12-29T23:18:59Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.6.2",
        "name": "v0.6.2",
        "tag_name": "v0.6.2",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.6.2",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/35825233",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.6.2"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "### Breaking changes\r\n- out: *atomnet, atomstat*\r\n- in: *models, trainers, predictors*\r\n\r\nTo install and use the old code run ```pip install git+https://github.com/ziatdinovmax/atomai@legacy --upgrade```\r\n\r\nThe new version provides an easy, Keras-like interface for training and applying models for semantic segmentation, image-to-spectrum conversion, as well as different forms of variational autoencoders. For example, to train a model for semantic segmentation of data, (for atom/defect finding) simply run:\r\n```python\r\nmodel = Segmentor()\r\nmodel.fit(X, y, X_test, y_test, training_cycles=300)\r\n```\r\nTo make a prediction with a trained model, run:\r\n```python\r\noutput, coords = model.predict(expdata)\r\n```\r\nSee the updated [documentation](https://atomai.readthedocs.io/en/latest/?badge=latest#) for more details.\r\n\r\n### New functionalities:\r\n- ImSpec models for converting 2D images to 1D spectra and vice versa\r\n- Graph analysis for identifying topologcial defects in the lattices\r\n- Class-conditioned VAE and rVAE\r\n\r\n### Imrovements:\r\n- AtomAI's trainers and predictors can now work with custom Pytorch models\r\n",
        "dateCreated": "2020-12-07T07:12:47Z",
        "datePublished": "2020-12-07T07:22:59Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.6.0",
        "name": "v0.6.0",
        "tag_name": "v0.6.0",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.6.0",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/34913511",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.6.0"
      },
      {
        "authorType": "User",
        "author_name": "ziatdinovmax",
        "body": "New functionalities:\r\n- Optional time-dependent weight perturbation w <- w + N(0, scale(t)) during NN model/ensemble training\r\n- Vanilla Pytorch NN training loop (the customized on-the-fly data augmentation is not available in this mode)\r\n- Basic utilities for working with graphs including:\r\n  - Construction of graph from NN output\r\n  - First-depth search for analyzing lattice topology\r\n  - Using connected/disconnected subgraphs to clean the NN predictions\r\n  - Plotting graphs\r\n\r\nBug fixes/improvements:\r\n- fix bug that prevented NN training in a 'full_epoch' mode for multiclass case\r\n- automatically load VAE's weights on cpu when cuda is not found\r\n- return subimages together with VAE-encoded trajectories\r\n- option to pass a custom latent variable range when plotting the VAE's manifold2d\r\n",
        "dateCreated": "2020-09-21T01:09:09Z",
        "datePublished": "2020-09-21T13:30:27Z",
        "html_url": "https://github.com/pycroscopy/atomai/releases/tag/v0.5.2",
        "name": "v0.5.2",
        "tag_name": "v0.5.2",
        "tarball_url": "https://api.github.com/repos/pycroscopy/atomai/tarball/v0.5.2",
        "url": "https://api.github.com/repos/pycroscopy/atomai/releases/31604980",
        "zipball_url": "https://api.github.com/repos/pycroscopy/atomai/zipball/v0.5.2"
      }
    ],
    "technique": "GitHub API"
  },
  "stargazers_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 45,
      "date": "Wed, 29 Dec 2021 05:07:59 GMT"
    },
    "technique": "GitHub API"
  },
  "topics": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "microscopy",
      "materials",
      "machine-learning",
      "materials-science",
      "deep-learning",
      "multivariate-analysis",
      "fully-convolutional-networks",
      "variational-autoencoders",
      "ensemble-learning",
      "google-colaboratory",
      "jupyter-notebook",
      "pytorch",
      "semantic-segmentation",
      "electron-microscopy",
      "scanning-probe-microscopy",
      "deep-kernel-learning"
    ],
    "technique": "GitHub API"
  }
}