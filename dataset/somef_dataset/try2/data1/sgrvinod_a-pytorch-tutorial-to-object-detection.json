{
  "arxivLinks": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://arxiv.org/abs/1512.02325",
      "https://arxiv.org/abs/1312.2249"
    ],
    "technique": "Regular expression"
  },
  "citation": [
    {
      "confidence": [
        0.9146894306581498
      ],
      "excerpt": "Object Detection. duh. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9349926227390687
      ],
      "excerpt": "Consider the following scenario. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8962890844937043
      ],
      "excerpt": "| conv8_2      | 10, 10       | 0.375 | 1:1, 2:1, 1:2, 3:1, 1:3 + an extra prior | 6 | 600 | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8356013927728488
      ],
      "excerpt": "| person | 0.7884440422058105 | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8275296219550469
      ],
      "excerpt": "original_image = PIL.Image.open(img_path, mode='r') \n",
      "technique": "Supervised classification"
    }
  ],
  "codeRepository": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/sgrvinod/a-PyTorch-Tutorial-to-Object-Detection",
    "technique": "GitHub API"
  },
  "dateCreated": {
    "confidence": [
      1.0
    ],
    "excerpt": "2018-10-17T16:39:03Z",
    "technique": "GitHub API"
  },
  "dateModified": {
    "confidence": [
      1.0
    ],
    "excerpt": "2021-12-23T08:46:50Z",
    "technique": "GitHub API"
  },
  "description": [
    {
      "confidence": [
        1
      ],
      "excerpt": "This data contains images with twenty different types of objects.\n\n```python\n{'aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', 'horse', 'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'}\n```\n\nEach image can contain one or more ground truth objects.\n\nEach object is represented by \u2013\n\n- a bounding box in absolute boundary coordinates\n\n- a label (one of the object types mentioned above)\n\n-  a perceived detection difficulty (either `0`, meaning _not difficult_, or `1`, meaning _difficult_)\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        0.8961788722743835
      ],
      "excerpt": "We will be implementing the Single Shot Multibox Detector (SSD), a popular, powerful, and especially nimble network for this task. The authors' original implementation can be found here. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9440163332415736
      ],
      "excerpt": "There are more examples at the end of the tutorial. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9779372270815391,
        0.9473840856831307,
        0.9440319636005136,
        0.845227179679448,
        0.9912804059233898,
        0.9687461126083339,
        0.8458751137749798,
        0.9266158111869913
      ],
      "excerpt": "Single-Shot Detection. Earlier architectures for object detection consisted of two distinct stages \u2013 a region proposal network that performs object localization and a classifier for detecting the types of objects in the proposed regions. Computationally, these can be very expensive and therefore ill-suited for real-world, real-time applications. Single-shot models encapsulate both localization and detection tasks in a single forward sweep of the network, resulting in significantly faster detections while deployable on lighter hardware. \nMultiscale Feature Maps. In image classification tasks, we base our predictions on the final convolutional feature map \u2013 the smallest but deepest representation of the original image. In object detection, feature maps from intermediate convolutional layers can also be directly useful because they represent the original image at different scales. Therefore, a fixed-size filter operating on different feature maps will be able to detect objects of various sizes. \nPriors. These are pre-computed boxes defined at specific positions on specific feature maps, with specific aspect ratios and scales. They are carefully chosen to match the characteristics of objects' bounding boxes (i.e. the ground truths) in the dataset. \nMultibox. This is a technique that formulates predicting an object's bounding box as a regression problem, wherein a detected object's coordinates are regressed to its ground truth's coordinates. In addition, for each predicted box, scores are generated for various object types. Priors serve as feasible starting points for predictions because they are modeled on the ground truths. Therefore, there will be as many predicted boxes as there are priors, most of whom will contain no object. \nHard Negative Mining. This refers to explicitly choosing the most egregious false positives predicted by a model and forcing it to learn from these examples. In other words, we are mining only those negatives that the model found hardest to identify correctly. In the context of object detection, where the vast majority of predicted boxes do not contain an object, this also serves to reduce the negative-positive imbalance. \nNon-Maximum Suppression. At any given location, multiple priors can overlap significantly. Therefore, predictions arising out of these priors could actually be duplicates of the same object. Non-Maximum Suppression (NMS) is a means to remove redundant predictions by suppressing all but the one with the maximum score. \nIn this section, I will present an overview of this model. If you're already familiar with it, you can skip straight to the Implementation section or the commented code. \nAs we proceed, you will notice that there's a fair bit of engineering that's resulted in the SSD's very specific structure and formulation. Don't worry if some aspects of it seem contrived or unspontaneous at first. Remember, it's built upon years of (often empirical) research in this field. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8255928609150464,
        0.9335032609487998
      ],
      "excerpt": "In this tutorial, we will encounter both types \u2013 just boxes and bounding boxes. But all boxes are represented on images and we need to be able to measure their positions, shapes, sizes, and other properties. \nThe most obvious way to represent a box is by the pixel coordinates of the x and y lines that constitute its boundaries. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8625287487814651,
        0.9046752238242458
      ],
      "excerpt": "But pixel values are next to useless if we don't know the actual dimensions of the image. \nA better way would be to represent all coordinates is in their fractional form. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8974578263371337
      ],
      "excerpt": "This is a more explicit way of representing a box's position and dimensions. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8057361723546124
      ],
      "excerpt": "The Jaccard Index or Jaccard Overlap or Intersection-over-Union (IoU) measure the degree or extent to which two boxes overlap. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9690320210190796,
        0.9297378521693924
      ],
      "excerpt": "It's a simple metric, but also one that finds many applications in our model. \nMultibox is a technique for detecting objects where a prediction consists of two components \u2013 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9654550294067168
      ],
      "excerpt": "The SSD is a purely convolutional neural network (CNN) that we can organize into three parts \u2013 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8958677092742352
      ],
      "excerpt": "Auxiliary convolutions added on top of the base network that will provide higher-level feature maps. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9875833247157556,
        0.931186141998072
      ],
      "excerpt": "The paper demonstrates two variants of the model called the SSD300 and the SSD512. The suffixes represent the size of the input image. Although the two networks differ slightly in the way they are constructed, they are in principle the same. The SSD512 is just a larger network and results in marginally better performance. \nFor convenience, we will deal with the SSD300. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9907413970574352,
        0.8942818539519812,
        0.8605473095405113,
        0.8525343734752806,
        0.9903945974973037
      ],
      "excerpt": "Because models proven to work well with image classification are already pretty good at capturing the basic essence of an image. The same convolutional features are useful for object detection, albeit in a more local sense \u2013 we're less interested in the image as a whole than specific regions of it where objects are present. \nThere's also the added advantage of being able to use layers pretrained on a reliable classification dataset. As you may know, this is called Transfer Learning. By borrowing knowledge from a different but closely related task, we've made progress before we've even begun. \nThe authors of the paper employ the VGG-16 architecture as their base network. It's rather simple in its original form. \nThey recommend using one that's pretrained on the ImageNet Large Scale Visual Recognition Competition (ILSVRC) classification task. Luckily, there's one already available in PyTorch, as are other popular architectures. If you wish, you could opt for something larger like the ResNet. Just be mindful of the computational requirements.   \nAs per the paper, we've to make some changes to this pretrained network to adapt it to our own challenge of object detection. Some are logical and necessary, while others are mostly a matter of convenience or preference. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.954442970682455,
        0.9104015411012335
      ],
      "excerpt": "The 3rd pooling layer, which halves dimensions, will use the mathematical ceiling function instead of the default floor function in determining output size. This is significant only if the dimensions of the preceding feature map are odd and not even. By looking at the image above, you could calculate that for our input image size of 300, 300, the conv3_3 feature map will be of cross-section 75, 75, which is halved to 38, 38 instead of an inconvenient 37, 37. \nWe modify the 5th pooling layer from a 2, 2 kernel and 2 stride to a 3, 3 kernel and 1 stride. The effect this has is it no longer halves the dimensions of the feature map from the preceding convolutional layer. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9751959031009412
      ],
      "excerpt": "In this example, there's an image of dimensions 2, 2, 3, flattened to a 1D vector of size 12. For an output of size 2, the fully connected layer computes two dot-products of this flattened image with two vectors of the same size 12. These two vectors, shown in gray, are the parameters of the fully connected layer. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9500310388644079,
        0.8294193977673857
      ],
      "excerpt": "Here, the image of dimensions 2, 2, 3 need not be flattened, obviously. The convolutional layer uses two filters with 12 elements in the same shape as the image to perform two dot products. These two filters, shown in gray, are the parameters of the convolutional layer. \nBut here's the key part \u2013 in both scenarios, the outputs Y_0 and Y_1 are the same! \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9608038574193476
      ],
      "excerpt": "That on an image of size H, W with I input channels, a fully connected layer of output size N is equivalent to a convolutional layer with kernel size equal to the image size H, W and N output channels, provided that the parameters of the fully connected network N, H * W * I are the same as the parameters of the convolutional layer N, H, W, I. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.82654160848096,
        0.8793088594413787,
        0.8898262328860568,
        0.8985277185164181,
        0.8022906987422742,
        0.9291965035100993,
        0.8437766833518072
      ],
      "excerpt": "We now know how to convert fc6 and fc7 in the original VGG-16 architecture into conv6 and conv7 respectively. \nIn the ImageNet VGG-16 shown previously, which operates on images of size 224, 224, 3, you can see that the output of conv5_3 will be of size 7, 7, 512. Therefore \u2013 \nfc6 with a flattened input size of 7 * 7 * 512 and an output size of 4096 has parameters of dimensions 4096, 7 * 7 * 512. The equivalent convolutional layer conv6 has a 7, 7 kernel size and 4096 output channels, with reshaped parameters of dimensions 4096, 7, 7, 512. \nfc7 with an input size of 4096 (i.e. the output size of fc6) and an output size 4096 has parameters of dimensions 4096, 4096. The input could be considered as a 1, 1 image with 4096 input channels. The equivalent convolutional layer conv7 has a 1, 1 kernel size and 4096 output channels, with reshaped parameters of dimensions 4096, 1, 1, 4096. \nWe can see that conv6 has 4096 filters, each with dimensions 7, 7, 512, and conv7 has 4096 filters, each with dimensions 1, 1, 4096. \nThese filters are numerous and large \u2013 and computationally expensive. \nTo remedy this, the authors opt to reduce both their number and the size of each filter by subsampling parameters from the converted convolutional layers. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8821156087897833,
        0.9443957511278643,
        0.8900311735997064,
        0.9078385394787705,
        0.8781486960330084,
        0.9482712980795938,
        0.9100626255708294,
        0.8705639924975243,
        0.9133068092247825,
        0.9751163855461066,
        0.8593825107705195,
        0.9688188863791033,
        0.8297102824527895,
        0.9902116129765584
      ],
      "excerpt": "Based on the references in the paper, we will subsample by picking every mth parameter along a particular dimension, in a process known as decimation.   \nSince the kernel of conv6 is decimated from 7, 7 to 3,  3 by keeping only every 3rd value, there are now holes in the kernel. Therefore, we would need to make the kernel dilated or atrous. \nThis corresponds to a dilation of 3 (same as the decimation factor m = 3). However, the authors actually use a dilation of 6, possibly because the 5th pooling layer no longer halves the dimensions of the preceding feature map. \nWe are now in a position to present our base network, the modified VGG-16. \nIn the above figure, pay special attention to the outputs of conv4_3 and conv_7. You will see why soon enough. \nWe will now stack some more convolutional layers on top of our base network. These convolutions provide additional feature maps, each progressively smaller than the last. \nWe introduce four convolutional blocks, each with two layers. While size reduction happened through pooling in the base network, here it is facilitated by a stride of 2 in every second layer. \nAgain, take note of the feature maps from conv8_2, conv9_2, conv10_2, and conv11_2. \nBefore we move on to the prediction convolutions, we must first understand what it is we are predicting. Sure, it's objects and their positions, but in what form? \nIt is here that we must learn about priors and the crucial role they play in the SSD. \nObject predictions can be quite diverse, and I don't just mean their type. They can occur at any position, with any size and shape. Mind you, we shouldn't go as far as to say there are infinite possibilities for where and how an object can occur. While this may be true mathematically, many options are simply improbable or uninteresting. Furthermore, we needn't insist that boxes are pixel-perfect. \nIn effect, we can discretize the mathematical space of potential predictions into just thousands of possibilities. \nPriors are precalculated, fixed boxes which collectively represent this universe of probable and approximate box predictions. \nPriors are manually but carefully chosen based on the shapes and sizes of ground truth objects in our dataset. By placing these priors at every possible location in a feature map, we also account for variety in position. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8748384600804663,
        0.9777970386736808,
        0.9768384516292428
      ],
      "excerpt": "they will be applied to various low-level and high-level feature maps, viz. those from conv4_3, conv7, conv8_2, conv9_2, conv10_2, and conv11_2. These are the same feature maps indicated on the figures before. \nif a prior has a scale s, then its area is equal to that of a square with side s. The largest feature map, conv4_3, will have priors with a scale of 0.1, i.e. 10% of image's dimensions, while the rest have priors with scales linearly increasing from 0.2 to 0.9. As you can see, larger feature maps have priors with smaller scales and are therefore ideal for detecting smaller objects. \nAt each position on a feature map, there will be priors of various aspect ratios. All feature maps will have priors with ratios 1:1, 2:1, 1:2. The intermediate feature maps of conv7, conv8_2, and conv9_2 will also have priors with ratios 3:1, 1:3. Moreover, all feature maps will have one extra prior with an aspect ratio of 1:1 and at a scale that is the geometric mean of the scales of the current and subsequent feature map. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8562712481093566,
        0.957638348350826
      ],
      "excerpt": "There are a total of 8732 priors defined for the SSD300! \nWe defined the priors in terms of their scales and aspect ratios. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8902071707978167,
        0.930280846438794
      ],
      "excerpt": "For example, let's try to visualize what the priors will look like at the central tile of the feature map from conv9_2. \nThe same priors also exist for each of the other tiles. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9162156255904232
      ],
      "excerpt": "Again, I would like to reiterate that the priors represent, approximately, the possibilities for prediction. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8509365300653691
      ],
      "excerpt": "So if each predicted bounding box is a slight deviation from a prior, and our goal is to calculate this deviation, we need a way to measure or quantify it. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8938827150266921
      ],
      "excerpt": "Assume they are represented in center-size coordinates, which we are familiar with. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9558821138801957,
        0.8058396935152671,
        0.8846269809685919
      ],
      "excerpt": "This answers the question we posed at the beginning of this section. Considering that each prior is adjusted to obtain a more precise prediction, these four offsets (g_c_x, g_c_y, g_w, g_h) are the form in which we will regress bounding boxes' coordinates. \nAs you can see, each offset is normalized by the corresponding dimension of the prior. This makes sense because a certain offset would be less significant for a larger prior than it would be for a smaller prior. \nEarlier, we earmarked and defined priors for six feature maps of various scales and granularity, viz. those from conv4_3, conv7, conv8_2, conv9_2, conv10_2, and conv11_2. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9015129358944529
      ],
      "excerpt": "a localization prediction convolutional layer with a 3,  3 kernel evaluating at each location (i.e. with padding and stride of 1) with 4 filters for each prior present at the location. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8755465599507887,
        0.9765438963568323,
        0.995510088980753,
        0.9614494258406759
      ],
      "excerpt": "a class prediction convolutional layer with a 3,  3 kernel evaluating at each location (i.e. with padding and stride of 1) with n_classes filters for each prior present at the location. \nThe n_classes filters for a prior calculate a set of n_classes scores for that prior. \nAll our filters are applied with a kernel size of 3, 3. \nWe don't really need kernels (or filters) in the same shapes as the priors because the different filters will learn to make predictions with respect to the different prior shapes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8736667244115577,
        0.882048118821448
      ],
      "excerpt": "The outputs of the localization and class prediction layers are shown in blue and yellow respectively. You can see that the cross-section (5, 5) remains unchanged. \nWhat we're really interested in is the third dimension, i.e. the channels. These contain the actual predictions. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.911404854901011
      ],
      "excerpt": "Voil\u00e0! The channel values at each position of the localization predictions represent the encoded offsets with respect to the priors at that position. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9247634694060939,
        0.8545293903204148,
        0.958761166483138,
        0.9181446602086978,
        0.890672064939013,
        0.8360721442438859,
        0.8151380212163851,
        0.9615047659039818
      ],
      "excerpt": "Similar to before, these channels represent the class scores for the priors at that position. \nNow that we understand what the predictions for the feature map from conv9_2 look like, we can reshape them into a more amenable form. \nWe have arranged the 150 predictions serially. To the human mind, this should appear more intuitive. \nBut let's not stop here. We could do the same for the predictions for all layers and stack them together. \nWe calculated earlier that there are a total of 8732 priors defined for our model. Therefore, there will be 8732 predicted boxes in encoded-offset form, and 8732 sets of class scores. \nThis is the final output of the prediction stage. A stack of boxes, if you will, and estimates for what's in them. \nIt's all coming together, isn't it? If this is your first rodeo in object detection, I should think there's now a faint light at the end of the tunnel. \nBased on the nature of our predictions, it's easy to see why we might need a unique loss function. Many of us have calculated losses in regression or classification settings before, but rarely, if ever, together. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9604950704264782,
        0.9912792993639442,
        0.9914681658090367
      ],
      "excerpt": "Phew. Let's get to work. \nRemember, the nub of any supervised learning algorithm is that we need to be able to match predictions to their ground truths. This is tricky since object detection is more open-ended than the average learning task. \nFor the model to learn anything, we'd need to structure the problem in a way that allows for comparisions between our predictions and the objects actually present in the image. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9200030200914724,
        0.8955225799701336,
        0.935899997910301,
        0.9632066634895631
      ],
      "excerpt": "Match each of the 8732 priors to the object with which it has the greatest overlap. \nIf a prior is matched with an object with a Jaccard overlap of less than 0.5, then it cannot be said to \"contain\" the object, and is therefore a negative match. Considering we have thousands of priors, most priors will test negative for an object. \nOn the other hand, a handful of priors will actually overlap significantly (greater than 0.5) with an object, and can be said to \"contain\" that object. These are positive matches. \nNow that we have matched each of the 8732 priors to a ground truth, we have, in effect, also matched the corresponding 8732 predictions to a ground truth.   \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9305854349381422
      ],
      "excerpt": "For convenience, we will assume there are just seven priors, shown in red. The ground truths are in yellow \u2013 there are three actual objects in this image. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8678322669092187,
        0.8989440966241438,
        0.9219137896136869,
        0.9498792975756952,
        0.91405043764901,
        0.8750831225887628,
        0.9763444392465306,
        0.9910600283039469
      ],
      "excerpt": "Predictions that are positively matched with an object now have ground truth coordinates that will serve as targets for localization, i.e. in the regression task. Naturally, there will be no target coordinates for negative matches. \nAll predictions have a ground truth label, which is either the type of object if it is a positive match or a background class if it is a negative match. These are used as targets for class prediction, i.e. the classification task. \nWe have no ground truth coordinates for the negative matches. This makes perfect sense. Why train the model to draw boxes around empty space? \nTherefore, the localization loss is computed only on how accurately we regress positively matched predicted boxes to the corresponding ground truth coordinates. \nSince we predicted localization boxes in the form of offsets (g_c_x, g_c_y, g_w, g_h), we would also need to encode the ground truth coordinates accordingly before we calculate the loss. \nThe localization loss is the averaged Smooth L1 loss between the encoded offsets of positively matched localization boxes and their ground truths. \nEvery prediction, no matter positive or negative, has a ground truth label associated with it. It is important that the model recognizes both objects and a lack of them. \nHowever, considering that there are usually only a handful of objects in an image, the vast majority of the thousands of predictions we made do not actually contain an object. As Walter White would say, tread lightly. If the negative matches overwhelm the positive ones, we will end up with a model that is less likely to detect objects because, more often than not, it is taught to detect the background class. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9740358457372977,
        0.9643010877824829,
        0.9337210430278231,
        0.8520428831353684,
        0.9629365253390777,
        0.8568367356253288
      ],
      "excerpt": "Well, why not use the ones that the model was most wrong about? In other words, only use those predictions where the model found it hardest to recognize that there are no objects. This is called Hard Negative Mining. \nThe number of hard negatives we will use, say N_hn, is usually a fixed multiple of the number of positive matches for this image. In this particular case, the authors have decided to use three times as many hard negatives, i.e. N_hn = 3 * N_p. The hardest negatives are discovered by finding the Cross Entropy loss for each negatively matched prediction and choosing those with top N_hn losses. \nThen, the confidence loss is simply the sum of the Cross Entropy losses among the positive and hard negative matches. \nYou will notice that it is averaged by the number of positive matches. \nThe Multibox loss is the aggregate of the two losses, combined in a ratio \u03b1. \nIn general, we needn't decide on a value for \u03b1. It could be a learnable parameter. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8626959033678276
      ],
      "excerpt": "After the model is trained, we can apply it to images. However, the predictions are still in their raw form \u2013 two tensors containing the offsets and class scores for 8732 priors. These would need to be processed to obtain final, human-interpretable bounding boxes with labels. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8289144731401363
      ],
      "excerpt": "Extract the scores for this class for each of the 8732 boxes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9564577544806028
      ],
      "excerpt": "At this point, if you were to draw these candidate boxes on the original image, you'd see many highly overlapping boxes that are obviously redundant. This is because it's extremely likely that, from the thousands of priors at our disposal, more than one prediction corresponds to the same object. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9671401771378286
      ],
      "excerpt": "There's clearly only three objects in it \u2013 two dogs and a cat. But according to the model, there are three dogs and two cats. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8027283494479762
      ],
      "excerpt": "Now, to you, it may be obvious which boxes are referring to the same object. This is because your mind can process that certain boxes coincide significantly with each other and a specific object. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9705031677313701,
        0.9252535436668978
      ],
      "excerpt": "The next step is to find which candidates are redundant. We already have a tool at our disposal to judge how much two boxes have in common with each other \u2013 the Jaccard overlap. \nSo, if we were to draw up the Jaccard similarities between all the candidates in a given class, we could evaluate each pair and if found to overlap significantly, keep only the more likely candidate. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9854649053381835,
        0.819429231710782
      ],
      "excerpt": "This process is called Non-Maximum Suppression (NMS) because when multiple candidates are found to overlap significantly with each other such that they could be referencing the same object, we suppress all but the one with the maximum score. \nAlgorithmically, it is carried out as follows \u2013 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8880236646060484,
        0.9881151582475413,
        0.9827862946104013
      ],
      "excerpt": "Arrange candidates for this class in order of decreasing likelihood. \nConsider the candidate with the highest score. Eliminate all candidates with lesser scores that have a Jaccard overlap of more than, say, 0.5 with this candidate. \nConsider the next highest-scoring candidate still remaining in the pool. Eliminate all candidates with lesser scores that have a Jaccard overlap of more than 0.5 with this candidate. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8115314291650031,
        0.8070038669337001
      ],
      "excerpt": "Non-Maximum Suppression is quite crucial for obtaining quality detections. \nHappily, it's also the final step. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9417262984008022
      ],
      "excerpt": "They are meant to provide some context, but details are best understood directly from the code, which is quite heavily commented. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9414631722204777
      ],
      "excerpt": "Remember, we're using a VGG-16 base pretrained on ImageNet that is already available in PyTorch's torchvision module. This page details the preprocessing or transformation we would need to perform in order to use this model \u2013 pixel values must be in the range [0,1] and we must then normalize the image by the mean and standard deviation of the ImageNet images' RGB channels. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8878213531485462,
        0.9252585068384144,
        0.8683553926558063,
        0.9830154598991073,
        0.9526927615351723,
        0.8598582276675606,
        0.9076791305355985,
        0.9872903521240665,
        0.8707846769204876
      ],
      "excerpt": "Therefore, images fed to the model must be a Float tensor of dimensions N, 3, 300, 300, and must be normalized by the aforesaid mean and standard deviation. N is the batch size. \nWe would need to supply, for each image, the bounding boxes of the ground truth objects present in it in fractional boundary coordinates (x_min, y_min, x_max, y_max). \nSince the number of objects in any given image can vary, we can't use a fixed size tensor for storing the bounding boxes for the entire batch of N images. \nTherefore, ground truth bounding boxes fed to the model must be a list of length N, where each element of the list is a Float tensor of dimensions N_o, 4, where N_o is the number of objects present in that particular image. \nWe would need to supply, for each image, the labels of the ground truth objects present in it. \nEach label would need to be encoded as an integer from 1 to 20 representing the twenty different object types. In addition, we will add a background class with index 0, which indicates the absence of an object in a bounding box. (But naturally, this label will not actually be used for any of the ground truth objects in the dataset.) \nAgain, since the number of objects in any given image can vary, we can't use a fixed size tensor for storing the labels for the entire batch of N images. \nTherefore, ground truth labels fed to the model must be a list of length N, where each element of the list is a Long tensor of dimensions N_o, where N_o is the number of objects present in that particular image. \nAs you know, our data is divided into training and test splits. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8847541840920204,
        0.8765863885531142,
        0.8930548183208625
      ],
      "excerpt": "A JSON file for each split with a list of the absolute filepaths of I images, where I is the total number of images in the split. \nA JSON file for each split with a list of I dictionaries containing ground truth objects, i.e. bounding boxes in absolute boundary coordinates, their encoded labels, and perceived detection difficulties. The ith dictionary in this list will contain the objects present in the ith image in the previous JSON file. \nA JSON file which contains the label_map, the label-to-index dictionary with which the labels are encoded in the previous JSON file. This dictionary is also available in utils.py and directly importable. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9917858833604283,
        0.9931106838811803,
        0.9636173903237236
      ],
      "excerpt": "This is a subclass of PyTorch Dataset, used to define our training and test datasets. It needs a __len__ method defined, which returns the size of the dataset, and a __getitem__ method which returns the ith image, bounding boxes of the objects in this image, and labels for the objects in this image, using the JSON files we saved earlier. \nYou will notice that it also returns the perceived detection difficulties of each of these objects, but these are not actually used in training the model. They are required only in the Evaluation stage for computing the Mean Average Precision (mAP) metric. We also have the option of filtering out difficult objects entirely from our data to speed up training at the cost of some accuracy. \nAdditionally, inside this class, each image and the objects in them are subject to a slew of transformations as described in the paper and outlined below. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8796757363571565,
        0.992976451071647,
        0.9916091842097755,
        0.9312453185351517,
        0.9901858447587369,
        0.9190371560485038,
        0.9921393766207927,
        0.9113563235592231,
        0.9291743956280587,
        0.899941147036008
      ],
      "excerpt": "Randomly adjust brightness, contrast, saturation, and hue, each with a 50% chance and in random order. \nWith a 50% chance, perform a zoom out operation on the image. This helps with learning to detect small objects. The zoomed out image must be between 1 and 4 times as large as the original. The surrounding space could be filled with the mean of the ImageNet data. \nRandomly crop image, i.e. perform a zoom in operation. This helps with learning to detect large or partial objects. Some objects may even be cut out entirely. Crop dimensions are to be between 0.3 and 1 times the original dimensions. The aspect ratio is to be between 0.5 and 2. Each crop is made such that there is at least one bounding box remaining that has a Jaccard overlap of either 0, 0.1, 0.3, 0.5, 0.7, or 0.9, randomly chosen, with the cropped image. In addition, any bounding boxes remaining whose centers are no longer in the image as a result of the crop are discarded. There is also a chance that the image is not cropped at all. \nWith a 50% chance, horizontally flip the image. \nResize the image to 300, 300 pixels. This is a requirement of the SSD300. \nConvert all boxes from absolute to fractional boundary coordinates. At all stages in our model, all boundary and center-size coordinates will be in their fractional forms. \nNormalize the image with the mean and standard deviation of the ImageNet data that was used to pretrain our VGG base. \nAs mentioned in the paper, these transformations play a crucial role in obtaining the stated results. \nThe Dataset described above, PascalVOCDataset, will be used by a PyTorch DataLoader in train.py to create and feed batches of data to the model for training or evaluation. \nSince the number of objects vary across different images, their bounding boxes, labels, and difficulties cannot simply be stacked together in the batch. There would be no way of knowing which objects belong to which image. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8375647931087755
      ],
      "excerpt": "See VGGBase in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9018684048624158,
        0.8228573109353808,
        0.8375647931087755
      ],
      "excerpt": "The layers are initialized with parameters from a pretrained VGG-16 with the load_pretrained_layers() method. \nWe're especially interested in the lower-level feature maps that result from conv4_3 and conv7, which we return for use in subsequent stages. \nSee AuxiliaryConvolutions in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8318681424279891,
        0.8113458658813861,
        0.8375647931087755,
        0.8898410241732612,
        0.8980669445063639,
        0.9687569088915028
      ],
      "excerpt": "Use a uniform Xavier initialization for the parameters of these layers. \nWe're especially interested in the higher-level feature maps that result from conv8_2, conv9_2, conv10_2 and conv11_2, which we return for use in subsequent stages. \nSee PredictionConvolutions in model.py. \nHere, we create and apply localization and class prediction convolutions to the feature maps from conv4_3, conv7, conv8_2, conv9_2, conv10_2 and conv11_2. \nThese layers are initialized in a manner similar to the auxiliary convolutions. \nWe also reshape the resulting prediction maps and stack them as discussed. Note that reshaping in PyTorch is only possible if the original tensor is stored in a contiguous chunk of memory. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8375647931087755,
        0.8599392364341385,
        0.9405820688215342,
        0.8661511436881404,
        0.9365394324791712,
        0.9869999609149317,
        0.8375647931087755,
        0.816914261769109,
        0.9098365227071132,
        0.9681689296224557,
        0.9870075138737082,
        0.9891018059905596,
        0.8375261106646897,
        0.9488165809664291,
        0.975396402433917,
        0.859855031341671
      ],
      "excerpt": "See SSD300 in model.py. \nHere, the base, auxiliary, and prediction convolutions are combined to form the SSD. \nThere is a small detail here \u2013 the lowest level features, i.e. those from conv4_3, are expected to be on a significantly different numerical scale compared to its higher-level counterparts. Therefore, the authors recommend L2-normalizing and then rescaling each of its channels by a learnable value. \nSee create_prior_boxes() under SSD300 in model.py. \nThis function creates the priors in center-size coordinates as defined for the feature maps from conv4_3, conv7, conv8_2, conv9_2, conv10_2 and conv11_2, in that order. Furthermore, for each feature map, we create the priors at each tile by traversing it row-wise. \nThis ordering of the 8732 priors thus obtained is very important because it needs to match the order of the stacked predictions. \nSee MultiBoxLoss in model.py. \nTwo empty tensors are created to store localization and class prediction targets, i.e. ground truths, for the 8732 predicted boxes in each image. \nWe find the ground truth object with the maximum Jaccard overlap for each prior, which is stored in object_for_each_prior. \nWe want to avoid the rare situation where not all of the ground truth objects have been matched. Therefore, we also find the prior with the maximum overlap for each ground truth object, stored in prior_for_each_object. We explicitly add these matches to object_for_each_prior and artificially set their overlaps to a value above the threshold so they are not eliminated. \nBased on the matches in object_for_each prior, we set the corresponding labels, i.e. targets for class prediction, to each of the 8732 priors. For those priors that don't overlap significantly with their matched objects, the label is set to background. \nAlso, we encode the coordinates of the 8732 matched objects in object_for_each prior in offset form (g_c_x, g_c_y, g_w, g_h) with respect to these priors, to form the targets for localization. Not all of these 8732 localization targets are meaningful. As we discussed earlier, only the predictions arising from the non-background priors will be regressed to their targets. \nThe localization loss is the Smooth L1 loss over the positive matches. \nPerform Hard Negative Mining \u2013 rank class predictions matched to background, i.e. negative matches, by their individual Cross Entropy losses. The confidence loss is the Cross Entropy loss over the positive matches and the hardest negative matches. Nevertheless, it is averaged only by the number of positive matches. \nThe Multibox Loss is the aggregate of these two losses, combined in the ratio \u03b1. In our case, they are simply being added because \u03b1 = 1. \nBefore you begin, make sure to save the required data files for training and evaluation. To do this, run the contents of create_data_lists.py after pointing it to the VOC2007 and VOC2012 folders in your downloaded data. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8735656413253229
      ],
      "excerpt": "The parameters for the model (and training it) are at the beginning of the file, so you can easily check or modify them should you need to. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9578965700958564,
        0.977525105902872
      ],
      "excerpt": "To resume training at a checkpoint, point to the corresponding file with the checkpoint parameter at the beginning of the code. \nIn the paper, they recommend using Stochastic Gradient Descent in batches of 32 images, with an initial learning rate of 1e\u22123, momentum of 0.9, and 5e-4 weight decay. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.99013908200759,
        0.9615007442855968,
        0.8726172870501249
      ],
      "excerpt": "The authors also doubled the learning rate for bias parameters. As you can see in the code, this is easy do in PyTorch, by passing separate groups of parameters to the params argument of its SGD optimizer. \nThe paper recommends training for 80000 iterations at the initial learning rate. Then, it is decayed by 90% (i.e. to a tenth) for an additional 20000 iterations, twice. With the paper's batch size of 32, this means that the learning rate is decayed by 90% once after the 154th epoch and once more after the 193th epoch, and training is stopped after 232 epochs. I followed this schedule. \nOn a TitanX (Pascal), each epoch of training required about 6 minutes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8933871704141396
      ],
      "excerpt": "Note that this checkpoint should be loaded directly with PyTorch for evaluation or inference \u2013 see below. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9404189730709465,
        0.9948272621061977,
        0.8253683598313829,
        0.8965686872732255
      ],
      "excerpt": "The data-loading and checkpoint parameters for evaluating the model are at the beginning of the file, so you can easily check or modify them should you wish to. \nTo begin evaluation, simply run the evaluate() function with the data-loader and model checkpoint. Raw predictions for each image in the test set are obtained and parsed with the checkpoint's detect_objects() method, which implements this process. Evaluation has to be done at a min_score of 0.01, an NMS max_overlap of 0.45, and top_k of 200 to allow fair comparision of results with the paper and other implementations. \nParsed predictions are evaluated against the ground truth objects. The evaluation metric is the Mean Average Precision (mAP). If you're not familiar with this metric, here's a great explanation. \nWe will use calculate_mAP() in utils.py for this purpose. As is the norm, we will ignore difficult detections in the mAP calculation. But nevertheless, it is important to include them from the evaluation dataset because if the model does detect an object that is considered to be difficult, it must not be counted as a false positive. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9148257411981842
      ],
      "excerpt": "You can see that some objects, like bottles and potted plants, are considerably harder to detect than others. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9738496340962004
      ],
      "excerpt": "Point to the model you want to use for inference with the checkpoint parameter at the beginning of the code. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9675376398761424
      ],
      "excerpt": "This function first preprocesses the image by resizing and normalizing its RGB channels as required by the model. It then obtains raw predictions from the model, which are parsed by the detect_objects() method in the model. The parsed results are converted from fractional to absolute boundary coordinates, their labels are decoded with the label_map, and they are visualized on the image. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        1.0
      ],
      "excerpt": "SSD: Single Shot MultiBox Detector | a PyTorch Tutorial to Object Detection",
      "technique": "GitHub API"
    }
  ],
  "download": [
    {
      "confidence": [
        1
      ],
      "excerpt": "Specfically, you will need to download the following VOC datasets \u2013\n\n- [2007 _trainval_](http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar) (460MB)\n\n- [2012 _trainval_](http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar) (2GB)\n\n- [2007 _test_](http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar) (451MB)\n\nConsistent with the paper, the two _trainval_ datasets are to be used for training, while the VOC 2007 _test_ will serve as our test data.  \n\nMake sure you extract both the VOC 2007 _trainval_ and 2007 _test_ data to the same location, i.e. merge them.\n\n",
      "technique": "Header extraction"
    }
  ],
  "downloadUrl": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/sgrvinod/a-pytorch-tutorial-to-object-detection/releases",
    "technique": "GitHub API"
  },
  "faq": [
    {
      "confidence": [
        1
      ],
      "excerpt": "__I noticed that priors often overshoot the `3, 3` kernel employed in the prediction convolutions. How can the kernel detect a bound (of an object) outside it?__\n\nDon't confuse the kernel and its _receptive field_, which is the area of the original image that is represented in the kernel's field-of-view.\n\nFor example, on the `38, 38` feature map from `conv4_3`, a `3, 3` kernel covers an area of `0.08, 0.08` in fractional coordinates. The priors are `0.1, 0.1`, `0.14, 0.07`, `0.07, 0.14`, and `0.14, 0.14`.\n\nBut its receptive field, which [you can calculate](https://medium.com/mlreview/a-guide-to-receptive-field-arithmetic-for-convolutional-neural-networks-e0f514068807), is a whopping `0.36, 0.36`! Therefore, all priors (and objects contained therein) are present well inside it.\n\nKeep in mind that the receptive field grows with every successive convolution. For `conv_7` and the higher-level feature maps, a `3, 3` kernel's receptive field will cover the _entire_ `300, 300` image. But, as always, the pixels in the original image that are closer to the center of the kernel have greater representation, so it is still _local_ in a sense.\n\n---\n\n__While training, why can't we match predicted boxes directly to their ground truths?__\n\nWe cannot directly check for overlap or coincidence between predicted boxes and ground truth objects to match them because predicted boxes are not to be considered reliable, _especially_ during the training process. This is the very reason we are trying to evaluate them in the first place!\n\nAnd this is why priors are especially useful. We can match a predicted box to a ground truth box by means of the prior it is supposed to be approximating. It no longer matters how correct or wildly wrong the prediction is.\n\n---\n\n__Why do we even have a _background_ class if we're only checking which _non-background_ classes meet the threshold?__\n\nWhen there is no object in the approximate field of the prior, a high score for _background_ will dilute the scores of the other classes such that they will not meet the detection threshold.\n\n---\n\n__Why not simply choose the class with the highest score instead of using a threshold?__\n\nI think that's a valid strategy. After all, we implicitly conditioned the model to choose _one_ class when we trained it with the Cross Entropy loss. But you will find that you won't achieve the same performance as you would with a threshold.\n\nI suspect this is because object detection is open-ended enough that there's room for doubt in the trained model as to what's really in the field of the prior. For example, the score for _background_ may be high if there is an appreciable amount of backdrop visible in an object's bounding box. There may even be multiple objects present in the same approximate region. A simple threshold will yield all possibilities for our consideration, and it just works better.\n\nRedundant detections aren't really a problem since we're NMS-ing the hell out of 'em.\n\n\n---\n\n__Sorry, but I gotta ask... _[what's in the boooox?!](https://cnet4.cbsistatic.com/img/cLD5YVGT9pFqx61TuMtcSBtDPyY=/570x0/2017/01/14/6d8103f7-a52d-46de-98d0-56d0e9d79804/se7en.png)___\n\nHa.\n",
      "technique": "Header extraction"
    }
  ],
  "forks_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 599,
      "date": "Fri, 24 Dec 2021 03:40:28 GMT"
    },
    "technique": "GitHub API"
  },
  "forks_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/sgrvinod/a-PyTorch-Tutorial-to-Object-Detection/forks",
    "technique": "GitHub API"
  },
  "fullName": {
    "confidence": [
      1.0
    ],
    "excerpt": "sgrvinod/a-PyTorch-Tutorial-to-Object-Detection",
    "technique": "GitHub API"
  },
  "installation": [
    {
      "confidence": [
        0.8421892172549753
      ],
      "excerpt": "They recommend using one that's pretrained on the ImageNet Large Scale Visual Recognition Competition (ILSVRC) classification task. Luckily, there's one already available in PyTorch, as are other popular architectures. If you wish, you could opt for something larger like the ResNet. Just be mindful of the computational requirements.   \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8994258680806592
      ],
      "excerpt": "Following the steps outlined earlier will yield the following matches \u2013 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8185378535105076
      ],
      "excerpt": "Note that this checkpoint should be loaded directly with PyTorch for evaluation or inference \u2013 see below. \n",
      "technique": "Supervised classification"
    }
  ],
  "invocation": [
    {
      "confidence": [
        0.8017088307847385
      ],
      "excerpt": "<img src=\"./img/baseball.gif\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000001.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000022.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000069.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000082.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000144.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000139.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000116.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8659259975398079
      ],
      "excerpt": "<img src=\"./img/000098.jpg\"> \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.853492186136904
      ],
      "excerpt": "| Grand Total      |    \u2013    | \u2013 | \u2013 | \u2013 | 8732 priors | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8032057177906676
      ],
      "excerpt": "First, line up the candidates for each class in terms of how likely they are. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8953857110452929
      ],
      "excerpt": "See create_data_lists() in utils.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8094617085672094
      ],
      "excerpt": "A JSON file for each split with a list of the absolute filepaths of I images, where I is the total number of images in the split. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8032732621067625
      ],
      "excerpt": "See PascalVOCDataset in datasets.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8099849345054632
      ],
      "excerpt": "See transform() in utils.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8051770883950267
      ],
      "excerpt": "The Dataset described above, PascalVOCDataset, will be used by a PyTorch DataLoader in train.py to create and feed batches of data to the model for training or evaluation. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8190272727956023
      ],
      "excerpt": "See VGGBase in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8190272727956023
      ],
      "excerpt": "See AuxiliaryConvolutions in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8190272727956023
      ],
      "excerpt": "See PredictionConvolutions in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8190272727956023
      ],
      "excerpt": "See SSD300 in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8190272727956023
      ],
      "excerpt": "See MultiBoxLoss in model.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.887693680876764
      ],
      "excerpt": "See train.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8782343463986202,
        0.9503189345333785
      ],
      "excerpt": "To train your model from scratch, run this file \u2013 \npython train.py \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.829331557275343
      ],
      "excerpt": "You can download this pretrained model here. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8199969767767588
      ],
      "excerpt": "See eval.py. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8589534893990137
      ],
      "excerpt": "| train | 0.8655905723571777 | \n",
      "technique": "Supervised classification"
    }
  ],
  "issueTracker": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/sgrvinod/a-PyTorch-Tutorial-to-Object-Detection/issues{/number}",
    "technique": "GitHub API"
  },
  "languages": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "Python"
    ],
    "technique": "GitHub API"
  },
  "license": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "name": "MIT License",
      "url": "https://api.github.com/licenses/mit"
    },
    "technique": "GitHub API"
  },
  "licenseText": {
    "confidence": [
      1.0
    ],
    "excerpt": "b'MIT License\\n\\nCopyright (c) 2019 Sagar Vinodababu\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \"Software\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n'",
    "technique": "File Exploration"
  },
  "long_title": {
    "confidence": [
      1.0
    ],
    "excerpt": "Contents",
    "technique": "Regular expression"
  },
  "name": {
    "confidence": [
      1.0
    ],
    "excerpt": "a-PyTorch-Tutorial-to-Object-Detection",
    "technique": "GitHub API"
  },
  "owner": {
    "confidence": [
      1.0
    ],
    "excerpt": "sgrvinod",
    "technique": "GitHub API"
  },
  "ownerType": {
    "confidence": [
      1.0
    ],
    "excerpt": "User",
    "technique": "GitHub API"
  },
  "readme_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/sgrvinod/a-PyTorch-Tutorial-to-Object-Detection/blob/master/README.md",
    "technique": "GitHub API"
  },
  "stargazers_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 2411,
      "date": "Fri, 24 Dec 2021 03:40:28 GMT"
    },
    "technique": "GitHub API"
  },
  "topics": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "pytorch",
      "pytorch-tutorial",
      "object-detection",
      "single-shot-multibox-detector",
      "single-shot-detection",
      "object-recognition",
      "ssd",
      "tutorial",
      "detection"
    ],
    "technique": "GitHub API"
  },
  "usage": [
    {
      "confidence": [
        1
      ],
      "excerpt": "---\n\n<p align=\"center\">\n<img src=\"./img/000029.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000045.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000062.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000075.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000085.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000092.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000100.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000124.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000127.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000128.jpg\">\n</p>\n\n---\n\n<p align=\"center\">\n<img src=\"./img/000145.jpg\">\n</p>\n\n---\n\n",
      "technique": "Header extraction"
    }
  ]
}