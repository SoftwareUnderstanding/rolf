{
  "arxivLinks": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://arxiv.org/abs/1301.3781 (2013).](http://arxiv.org/pdf/1301.3781.pdf)  \n    For word2vec also R-packages are available [tmcn (A Text mining toolkit especially for Chinese)](https://r-forge.r-project.org/R/?group_id=1571) and [wordVectors](https://github.com/bmschmidt/wordVectors). An example application of *wordVectors* can be found [here](http://yamano357.hatenadiary.com/entry/2015/11/04/000332).\n    Furthermore it seems to be soon available in [h2o-3](https://github.com/h2oai/h2o-3/blob/master/h2o-r/h2o-package/R/word2vec.R).\n\n\n  + **PythonInR and Glove** [Example](https://gist.github.com/yamano357/8a31b2dc0c7a20a30d36)  \n    GloVe is an unsupervised learning algorithm for obtaining vector representations for words. More information can be found [here](http://nlp.stanford.edu/projects/glove/).   \n    [Jeffrey Pennington, Richard Socher, and Christopher D. Manning. \"Glove: Global vectors for word representation.\" Proceedings of the Empiricial Methods in Natural Language Processing (EMNLP 2014) 12 (2014): 1532-1543.](http://nlp.stanford.edu/pubs/glove.pdf)\n\n\n  + **PythonInR and TensorFlow** [Example](http://qiita.com/yamano357/items/66272759fc29a5a2dd01)  \n    TensorFlow is an open source software library for numerical computation using data flow graphs. More information can be found [here](http://www.tensorflow.org/).  \n    [Mart\u00edn Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S. Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew Harp, Geoffrey Irving, Michael Isard, Rafal Jozefowicz, Yangqing Jia, Lukasz Kaiser, Manjunath Kudlur, Josh Levenberg, Dan Man\u00e9, Mike Schuster, Rajat Monga, Sherry Moore, Derek Murray, Chris Olah, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker, Vincent Vanhoucke, Vijay Vasudevan, Fernanda Vi\u00e9gas, Oriol Vinyals, Pete Warden, Martin Wattenberg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. \"TensorFlow: Large-scale machine learning on heterogeneous systems.\" (2015).](http://download.tensorflow.org/paper/whitepaper2015.pdf)"
    ],
    "technique": "Regular expression"
  },
  "citation": [
    {
      "confidence": [
        0.8109194328925066
      ],
      "excerpt": "setMethod(\"pySetPoly\", signature(key=\"character\", value = \"integer\"), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9988641433034521
      ],
      "excerpt": "                   key, key, key, key) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8109194328925066
      ],
      "excerpt": "          signature(key=\"character\", value = \"integer\"), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8109194328925066
      ],
      "excerpt": "    PythonInR:::pySetSimple(key, value) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8714162992508173
      ],
      "excerpt": "setMethod(\"pyGetPoly\", signature(key=\"character\", autoTypecast = \"logical\", simplify = \"logical\", pyClass = \"PrMatrix\"), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8511535834563826
      ],
      "excerpt": "    x &lt;- pyExecg(sprintf(\"x = %s.toDict()\", key), autoTypecast = autoTypecast, simplify = simplify)[['x']] \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8511535834563826
      ],
      "excerpt": "setMethod(\"pyGetPoly\", signature(key=\"character\", autoTypecast = \"logical\", simplify = \"logical\", pyClass = \"type\"), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8714162992508173
      ],
      "excerpt": "    pyExecg(sprintf(\"x = %s.__name__\", key))[['x']] \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9535968566765157,
        0.8090016440670298
      ],
      "excerpt": "  if (grepl(\"^GeneratorWrapper\", class(object)[1])) { \n    class(object)[1] <- \"GeneratorWrapper\" \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8090016440670298
      ],
      "excerpt": "  object \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9990093496502941
      ],
      "excerpt": "T Mikolov, K Chen, G Corrado, J Dean . \"Efficient estimation of word representations in vector space.\" arXiv preprint arXiv:1301.3781 (2013). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9920945486118125
      ],
      "excerpt": "Jeffrey Pennington, Richard Socher, and Christopher D. Manning. \"Glove: Global vectors for word representation.\" Proceedings of the Empiricial Methods in Natural Language Processing (EMNLP 2014) 12 (2014): 1532-1543. \n",
      "technique": "Supervised classification"
    }
  ],
  "codeRepository": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/Sage-Bionetworks/PythonEmbedInR",
    "technique": "GitHub API"
  },
  "dateCreated": {
    "confidence": [
      1.0
    ],
    "excerpt": "2016-12-08T19:23:10Z",
    "technique": "GitHub API"
  },
  "dateModified": {
    "confidence": [
      1.0
    ],
    "excerpt": "2021-07-17T15:52:40Z",
    "technique": "GitHub API"
  },
  "description": [
    {
      "confidence": [
        0.9121922171430437
      ],
      "excerpt": "This package is a modification of PythonInR which embeds a private copy of Python, isolated from any Python installation that might be on the host system. The documentation of the original package follows. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8180728832371222,
        0.8786156920630592,
        0.908925214220865
      ],
      "excerpt": "Python classes for vectors, matrices and data.frames which allow  \nan easy conversion from R to Python and back. The names of the classes are PrVector, \nPrMatrix and PrDataFrame. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9561008889947729,
        0.8073589587226101
      ],
      "excerpt": "PythonInR is designed in way that the conversion of types can easily be added or changed. \nThis is done by utilizing polymorphism: if pySet is called, pySet calls pySetPoly \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8749108146451589
      ],
      "excerpt": "can be used to modify the behavior of pySet on the example of integer vectors. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8514244180073965,
        0.9557573179547575,
        0.8480790426195982
      ],
      "excerpt": "When executing pySet(\"x\", list(b=3, a=2)) and pyGet(\"x\") the order \nof the elements in x will change. This is not a special behavior of PythonInR \nbut the default behavior of Python for dictionaries. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8554265064598147
      ],
      "excerpt": "Matrices are either transformed to an object of the class PrMatrix or \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9191620875583978
      ],
      "excerpt": "Data frames are either transformed to an object of the class PrDataFrame \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8933094588950792,
        0.9066093400045842
      ],
      "excerpt": "Similar to pySet the behavior of pyGet can be changed by utilizing pyGetPoly. \nThe predefined version of pyGetPoly for an object of class PrMatrix looks like the following: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8802204585987596,
        0.9613088808939074
      ],
      "excerpt": "For objects of type \"type\" no conversion is defined. Therefore, PythonInR doesn't know how \nto transform it into an R object so it will return a PythonInR_Object. This is kind of a \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8495799940969914
      ],
      "excerpt": "The following tools help generate R functions that wrap Python functions along with reference documentation (.Rd files) for the wrapper functions. The R documentation is generated from the Sphinx-based Python docstrings. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8459974732485712
      ],
      "excerpt": "A Python package may have multiple modules, each with its own namespace. Each module has its own functions, classes, and variables. Each function or class has its own local namespace. In R, all functions and classes within the same package share a package namespace. To avoid the namespace collisions and allow customization to the wrapping package, we provide the following functions to help you pick which modules, functions, and classes to expose in R: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8854305570178457,
        0.9243887480373827,
        0.8955621103839708
      ],
      "excerpt": "The .Rd file generation must be invoked at the time the package is built, not at the time the package is loaded. The R function and constructor wrappers must be invoked at the time the package is loaded. \nTo generate the R package synapserutils, our first attempt is to expose all functions under the synapseutils Python module.  \nIn the synapserutils package, we add a configure file with the following content: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9269787024151623
      ],
      "excerpt": "Where createRdFiles.R is an R script we add to the package, containing the code to generate the .Rd documentation files. The script invokes generateRdFiles as shown below: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9297415602155474
      ],
      "excerpt": "* pyPkg is the name of the Python package that needs to be imported, and \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9549814309464555
      ],
      "excerpt": "To generate R wrappers for Python functions and constructors, we need to add an .onLoad hook in the R package. This hook is defined in synapserutils/R/zzz.R file: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9367863011355514
      ],
      "excerpt": ": For the R wrappers to be available in synapserutils package namespace, \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8468817892200198
      ],
      "excerpt": ": we need to define it in synapserutils and pass it through generateRWrappers. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.849552453682623
      ],
      "excerpt": "to generateRdFiles() so that the reference doc's match the generated R functions.  \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8597128368121085
      ],
      "excerpt": "For many reasons, some Python functions are meant to be used internally, and these do not need to be exposed in the R package. For example, notifyMe is a Python decorator, and can only be used for other Python functions. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8100048976766041
      ],
      "excerpt": "And from zzz.R, update generateRWrappers to maintain consistency as follows: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.877989472801833
      ],
      "excerpt": "* function: privateGet from any of the classes, and \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.923963208501184
      ],
      "excerpt": "In some cases, we want to expose a set of Python functions which are an object's methods, but without exposing the object itself. For example, in the synapser package we wish to make available the methods in synapseclient.client.Synapse without requiring the R user to instantiate the Synapse object. The following will create a singleton object at package load time and expose the object's methods to be called directly. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8146629525440175
      ],
      "excerpt": "And in R, users would not need to know about the Synapse object: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9093373840834055
      ],
      "excerpt": "    For word2vec also R-packages are available tmcn (A Text mining toolkit especially for Chinese) and wordVectors. An example application of wordVectors can be found here. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9454244881324259
      ],
      "excerpt": "    GloVe is an unsupervised learning algorithm for obtaining vector representations for words. More information can be found here.  \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9000988844102158
      ],
      "excerpt": "    TensorFlow is an open source software library for numerical computation using data flow graphs. More information can be found here. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        1.0
      ],
      "excerpt": "Based off of PythonInR (https://bitbucket.org/Floooo/pythoninr/) but includes a standalone, compiled from source python instead of relying on the python installed on the host machine",
      "technique": "GitHub API"
    }
  ],
  "downloadUrl": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/Sage-Bionetworks/PythonEmbedInR/releases",
    "technique": "GitHub API"
  },
  "forks_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 8,
      "date": "Tue, 21 Dec 2021 00:03:17 GMT"
    },
    "technique": "GitHub API"
  },
  "forks_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/Sage-Bionetworks/PythonEmbedInR/forks",
    "technique": "GitHub API"
  },
  "fullName": {
    "confidence": [
      1.0
    ],
    "excerpt": "Sage-Bionetworks/PythonEmbedInR",
    "technique": "GitHub API"
  },
  "installation": [
    {
      "confidence": [
        1
      ],
      "excerpt": "```r\ninstall.packages(\"PythonEmbedInR\", repos=c(\"http://cran.fhcrc.org\", \"http://ran.synapse.org\"))\n#: (Use your favorite CRAN mirror above.  See https://cran.r-project.org/mirrors.html for a list of available mirrors.)\n```\n\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        0.8231261218430294
      ],
      "excerpt": "This package is a modification of PythonInR which embeds a private copy of Python, isolated from any Python installation that might be on the host system. The documentation of the original package follows. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8646459075776246
      ],
      "excerpt": "To allow a nearly one to one conversion from R to Python, PythonInR provides \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8244453191770256
      ],
      "excerpt": "NOTE PythonInR:::pySetSimple \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8837680365796365
      ],
      "excerpt": "| Python      | R                    | simplify     | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8244453191770256
      ],
      "excerpt": "NOTE pyGetPoly \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8244453191770256
      ],
      "excerpt": "NOTE (bytes): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8837680365796365
      ],
      "excerpt": "| pyExit           | Close Python                                       | pyExit()                                                           | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.930492592731917,
        0.930492592731917
      ],
      "excerpt": "| pyGet            | Get a Python variable                              | pyGet('myPythonVariable')                                          | \n| pyGet0           | Get a Python variable                              | pyGet0('myPythonVariable')                                         | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8989728647222793
      ],
      "excerpt": "| pyVersion        | Returns the version of Python                      | pyVersion()                                                        | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9102558257128007
      ],
      "excerpt": "* The Python package is available on Python search path \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8214485025381365
      ],
      "excerpt": ": build the .Rd files \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8661176197453521
      ],
      "excerpt": "  setGeneric(name, def) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9640958186403861,
        0.9625196775343342
      ],
      "excerpt": ": package environment. \n.NAMESPACE <- environment() \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.858708473210551
      ],
      "excerpt": "    if (any(x$name == toOmit)) { \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8343222245639605
      ],
      "excerpt": "Note that we do not want the following from the synapseclient.entity module: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.858708473210551
      ],
      "excerpt": "    if (any(class$name == classToSkip)) { \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.858708473210551
      ],
      "excerpt": "            if (any(x$name == methodsToOmit)) NULL else x; \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8891401888405708
      ],
      "excerpt": "  syn.get() \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8838377520179606
      ],
      "excerpt": "Note that: \n",
      "technique": "Supervised classification"
    }
  ],
  "invocation": [
    {
      "confidence": [
        0.8535891714006877
      ],
      "excerpt": "    exec(compile(open(filename, 'rb').read(), filename, 'exec'), globals()) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8462486808122965,
        0.836609024877264
      ],
      "excerpt": "          function(key, value){ \n    success &lt;- pySetSimple(key, list(vector=unname(value), names=names(value), rClass=class(value))) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8462486808122965
      ],
      "excerpt": "          function(key, value){ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8206541690910788
      ],
      "excerpt": "to an numpy array (if the option useNumpy is set to TRUE). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8588393147199375,
        0.8768801849289117,
        0.8528752660038815,
        0.8768801849289117,
        0.8692907117857883,
        0.8768801849289117,
        0.873698113677474
      ],
      "excerpt": "| None        | NULL                 | TRUE / FALSE | \n| boolean     | logical              | TRUE / FALSE | \n| integer     | numeric              | TRUE / FALSE | \n| double      | numeric              | TRUE / FALSE | \n| string      | character            | TRUE / FALSE | \n| unicode     | character            | TRUE / FALSE | \n| bytes       | character            | TRUE / FALSE | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8281924757697854
      ],
      "excerpt": "| PrVetor     | vector               | TRUE / FALSE | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8380383178283315
      ],
      "excerpt": "| PrDataFrame | data.frame           | TRUE         | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8436640638741617
      ],
      "excerpt": "nice example since the return value of type(x) is a function therefore PythonInR will \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8542847556459349
      ],
      "excerpt": "| Command          | Short Description                                  | Example Usage                                                        | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9291078534175641
      ],
      "excerpt": "| BEGIN.Python     | Start a Python read-eval-print loop              | BEGIN.Python() print(\"Hello\" + \" \" + \"R!\") END.Python              | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8760214527587137
      ],
      "excerpt": "| pyExecp          | Execute and print Python Code                      | pyExecp('\"Hello\" + \" \" + \"R!\"')                                    | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9166852350060559
      ],
      "excerpt": "| pyImport         | Import a Python module                             | pyImport(\"numpy\", \"np\")                                            | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8043794252086239
      ],
      "excerpt": "                container = \"synapseutils\") \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8204232124994595
      ],
      "excerpt": "* srcRootDir is the path to synapserutils directory. The directory must exist prior to this call. generateRdFiles will create a folder auto-man and write the generated .Rd files in this folder. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8279944613674961
      ],
      "excerpt": "callback <- function(name, def) { \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8775044342876571,
        0.8385442360838824
      ],
      "excerpt": "assignEnumCallback <- function(name, keys, values) { \n  assign(name, setNames(values, keys), .NAMESPACE) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8043794252086239
      ],
      "excerpt": "                    container = \"synapseutils\", \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8043794252086239
      ],
      "excerpt": "                container = \"synapseutils\", \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8043794252086239
      ],
      "excerpt": "                  container = \"synapseutils\", \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8070126731204554
      ],
      "excerpt": "            class: File \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8070126731204554
      ],
      "excerpt": "class: File \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8043794252086239
      ],
      "excerpt": "                container = \"synapseclient.entity\", \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8043794252086239
      ],
      "excerpt": "                  container = \"synapseclient.entity\", \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8250601936805425
      ],
      "excerpt": "  #: change returned object name from \"GeneratorWrapper.<some function name>\" to \"GeneratorWrapper\" \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8488411244225242
      ],
      "excerpt": "* :var: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8778487586960795,
        0.8778487586960795,
        0.8550058263023677,
        0.9336801098518991,
        0.9336801098518991,
        0.9336801098518991
      ],
      "excerpt": "* :example(s): \n* :Example(s): \n* :py:class: \n* :py:mod: \n* :py:func: \n* :py:meth: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.829801466341879
      ],
      "excerpt": "PythonInR and TensorFlow Example \n",
      "technique": "Supervised classification"
    }
  ],
  "issueTracker": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/Sage-Bionetworks/PythonEmbedInR/issues{/number}",
    "technique": "GitHub API"
  },
  "languages": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "R",
      "C",
      "Python",
      "Shell"
    ],
    "technique": "GitHub API"
  },
  "license": {
    "confidence": [
      1.0
    ],
    "technique": "GitHub API"
  },
  "long_title": {
    "confidence": [
      1.0
    ],
    "excerpt": "# PythonEmbedInR - Access a private copy of Python embedded in this R package.",
    "technique": "Regular expression"
  },
  "name": {
    "confidence": [
      1.0
    ],
    "excerpt": "PythonEmbedInR",
    "technique": "GitHub API"
  },
  "owner": {
    "confidence": [
      1.0
    ],
    "excerpt": "Sage-Bionetworks",
    "technique": "GitHub API"
  },
  "ownerType": {
    "confidence": [
      1.0
    ],
    "excerpt": "Organization",
    "technique": "GitHub API"
  },
  "readme_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/Sage-Bionetworks/PythonEmbedInR/blob/master/README.md",
    "technique": "GitHub API"
  },
  "releases": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      {
        "authorType": "User",
        "author_name": "jkiang13",
        "body": "",
        "dateCreated": "2021-07-16T22:55:08Z",
        "datePublished": "2021-07-17T06:05:46Z",
        "html_url": "https://github.com/Sage-Bionetworks/PythonEmbedInR/releases/tag/0.8",
        "name": "0.8",
        "tag_name": "0.8",
        "tarball_url": "https://api.github.com/repos/Sage-Bionetworks/PythonEmbedInR/tarball/0.8",
        "url": "https://api.github.com/repos/Sage-Bionetworks/PythonEmbedInR/releases/46353243",
        "zipball_url": "https://api.github.com/repos/Sage-Bionetworks/PythonEmbedInR/zipball/0.8"
      }
    ],
    "technique": "GitHub API"
  },
  "requirement": [
    {
      "confidence": [
        1
      ],
      "excerpt": "**R** >= 2.15.0\n\n**R-packages:**\n- pack\n- R6\n- rjson\n- methods\n- stats\n\n\n",
      "technique": "Header extraction"
    }
  ],
  "stargazers_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 3,
      "date": "Tue, 21 Dec 2021 00:03:17 GMT"
    },
    "technique": "GitHub API"
  },
  "usage": [
    {
      "confidence": [
        1
      ],
      "excerpt": "In this example, I will demonstrate how we generate the [synapser](https://github.com/Sage-Bionetworks/synapser) and the [synapserutils](https://github.com/Sage-Bionetworks/synapserutils) packages by wrapping the Python package [synapsePythonClient](https://github.com/Sage-Bionetworks/synapsePythonClient).\n\nThe `synapseutils` module in `synapsePythonClient` package has the following structure:\n```\n    module: synapseutils\n        module: copy\n            function: copy\n            function: copyWiki\n            function: copyFileHandles\n        module: sync\n            function: syncToSynapse\n            function: syncFromSynapse\n        module: monitor\n            function: notifyMe\n```\n\n",
      "technique": "Header extraction"
    }
  ]
}