{
  "arxivLinks": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://arxiv.org/abs/1810.04805"
    ],
    "technique": "Regular expression"
  },
  "citation": [
    {
      "confidence": [
        0.8356013927728488
      ],
      "excerpt": "assert len(encoded_layers) == 12 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8356013927728488
      ],
      "excerpt": "  --train_batch_size 12 \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8356013927728488
      ],
      "excerpt": "Conditional generation: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8356013927728488
      ],
      "excerpt": "Unconditional generation: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8090016440670298
      ],
      "excerpt": "  $BERT_BASE_DIR/pytorch_model.bin \n",
      "technique": "Supervised classification"
    }
  ],
  "codeRepository": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/cedrickchee/pytorch-pretrained-BERT",
    "technique": "GitHub API"
  },
  "dateCreated": {
    "confidence": [
      1.0
    ],
    "excerpt": "2018-11-10T10:58:54Z",
    "technique": "GitHub API"
  },
  "dateModified": {
    "confidence": [
      1.0
    ],
    "excerpt": "2021-12-16T07:27:33Z",
    "technique": "GitHub API"
  },
  "description": [
    {
      "confidence": [
        1
      ],
      "excerpt": "BERT-base and BERT-large are respectively 110M and 340M parameters models and it can be difficult to fine-tune them on a single GPU with the recommended batch size for good performance (in most case a batch size of 32).\n\nTo help with fine-tuning these models, we have included several techniques that you can activate in the fine-tuning scripts [`run_classifier.py`](./examples/run_classifier.py) and [`run_squad.py`](./examples/run_squad.py): gradient-accumulation, multi-gpu training, distributed training and 16-bits training . For more details on how to use these techniques you can read [the tips on training large batches in PyTorch](https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255) that I published earlier this month.\n\nHere is how to use these techniques in our scripts:\n\n- **Gradient Accumulation**: Gradient accumulation can be used by supplying a integer greater than 1 to the `--gradient_accumulation_steps` argument. The batch at each step will be divided by this integer and gradient will be accumulated over `gradient_accumulation_steps` steps.\n- **Multi-GPU**: Multi-GPU is automatically activated when several GPUs are detected and the batches are splitted over the GPUs.\n- **Distributed training**: Distributed training can be activated by supplying an integer greater or equal to 0 to the `--local_rank` argument (see below).\n- **16-bits training**: 16-bits training, also called mixed-precision training, can reduce the memory requirement of your model on the GPU by using half-precision training, basically allowing to double the batch size. If you have a recent GPU (starting from NVIDIA Volta architecture) you should see no decrease in speed. A good introduction to Mixed precision training can be found [here](https://devblogs.nvidia.com/mixed-precision-training-deep-neural-networks/) and a full documentation is [here](https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html). In our scripts, this option can be activated by setting the `--fp16` flag and you can play with loss scaling using the `--loss_scale` flag (see the previously linked documentation for details on loss scaling). The loss scale can be zero in which case the scale is dynamically adjusted or a positive power of two in which case the scaling is static.\n\nTo use 16-bits training and distributed training, you need to install NVIDIA's apex extension [as detailed here](https://github.com/nvidia/apex). You will find more information regarding the internals of `apex` and how to use `apex` in [the doc and the associated repository](https://github.com/nvidia/apex). The results of the tests performed on pytorch-BERT by the NVIDIA team (and my trials at reproducing them) can be consulted in [the relevant PR of the present repository](https://github.com/huggingface/pytorch-pretrained-BERT/pull/116).\n\nNote: To use *Distributed Training*, you will need to run one training script on each of your machines. This can be done for example by running the following command on each server (see [the above mentioned blog post]((https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255)) for more details):\n```bash\npython -m torch.distributed.launch --nproc_per_node=4 --nnodes=2 --node_rank=$THIS_MACHINE_INDEX --master_addr=\"192.168.1.1\" --master_port=1234 run_classifier.py (--arg1 --arg2 --arg3 and all other arguments of the run_classifier script)\n```\nWhere `$THIS_MACHINE_INDEX` is an sequential index assigned to each of your machine (0, 1, 2...) and the machine with rank 0 has an IP address `192.168.1.1` and an open port `1234`.\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        0.8968606477359159,
        0.9060804580093317,
        0.860059181823877,
        0.9499201267290861,
        0.860059181823877,
        0.9254314210912358,
        0.8579826886658117,
        0.9655804832964046
      ],
      "excerpt": "This repository contains op-for-op PyTorch reimplementations, pre-trained models and fine-tuning examples for: \nGoogle's BERT model, \nOpenAI's GPT model, \nGoogle/CMU's Transformer-XL model, and \nOpenAI's GPT-2 model. \nThese implementations have been tested on several datasets (see the examples) and should match the performances of the associated TensorFlow implementations (e.g. ~91 F1 on SQuAD for BERT, ~88 F1 on RocStories for OpenAI GPT and ~18.3 perplexity on WikiText 103 for the Transformer-XL). You can find more details in the Examples section below. \nHere are some information on these models: \nBERT was released together with the paper BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8329926734334279,
        0.9201619577267895,
        0.8861946801249367,
        0.9673310924352768,
        0.8459794935593894,
        0.9764994052548521
      ],
      "excerpt": "OpenAI GPT was released together with the paper Improving Language Understanding by Generative Pre-Training by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever. \nThis PyTorch implementation of OpenAI GPT is an adaptation of the PyTorch implementation by HuggingFace and is provided with OpenAI's pre-trained model and a command-line interface that was used to convert the pre-trained NumPy checkpoint in PyTorch. \nGoogle/CMU's Transformer-XL was released together with the paper Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context by Zihang Dai, Zhilin Yang, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov. \nThis PyTorch implementation of Transformer-XL is an adaptation of the original PyTorch implementation which has been slightly modified to match the performances of the TensorFlow implementation and allow to re-use the pretrained weights. A command-line interface is provided to convert TensorFlow checkpoints in PyTorch models. \nOpenAI GPT-2 was released together with the paper Language Models are Unsupervised Multitask Learners by Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei and Ilya Sutskever. \nThis PyTorch implementation of OpenAI GPT-2 is an adaptation of the OpenAI's implementation and is provided with OpenAI's pre-trained model and a command-line interface that was used to convert the TensorFlow checkpoint in PyTorch. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8336281922542947
      ],
      "excerpt": "| Overview | Overview of the package | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9208740734648937
      ],
      "excerpt": "This package comprises the following classes that can be imported in Python and are detailed in the Doc section of this readme: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.821261652010981,
        0.8994617723377123,
        0.8377724871277259,
        0.8377724871277259
      ],
      "excerpt": "BertForSequenceClassification - BERT Transformer with a sequence classification head on top (BERT Transformer is pre-trained, the sequence classification head is only initialized and has to be trained), \nBertForMultipleChoice - BERT Transformer with a multiple choice head on top (used for task like Swag) (BERT Transformer is pre-trained, the multiple choice classification head is only initialized and has to be trained), \nBertForTokenClassification - BERT Transformer with a token classification head on top (BERT Transformer is pre-trained, the token classification head is only initialized and has to be trained), \nBertForQuestionAnswering - BERT Transformer with a token classification head on top (BERT Transformer is pre-trained, the token classification head is only initialized and has to be trained). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8677912878263523
      ],
      "excerpt": "OpenAIGPTDoubleHeadsModel - OpenAI GPT Transformer with the tied language modeling head and a multiple choice classification head on top (OpenAI GPT Transformer is pre-trained, the multiple choice classification head is only initialized and has to be trained), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8342552687181474
      ],
      "excerpt": "TransfoXLLMHeadModel - Transformer-XL with the tied adaptive softmax head on top for language modeling which outputs the logits/loss and memory cells (fully pre-trained), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8677912878263523
      ],
      "excerpt": "GPT2DoubleHeadsModel - OpenAI GPT-2 Transformer with the tied language modeling head and a multiple choice classification head on top (OpenAI GPT-2 Transformer is pre-trained, the multiple choice classification head is only initialized and has to be trained), \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8266877417631755
      ],
      "excerpt": "BertTokenizer - perform end-to-end tokenization, i.e. basic tokenization followed by WordPiece tokenization. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9794389748096579
      ],
      "excerpt": "BertAdam - Bert version of Adam algorithm with weight decay fix, warmup and linear decay of the learning rate. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9794389748096579
      ],
      "excerpt": "OpenAIAdam - OpenAI GPT version of Adam algorithm with weight decay fix, warmup and linear decay of the learning rate. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8128628906392836,
        0.8128628906392836,
        0.8128628906392836,
        0.8128628906392836,
        0.8756093850587273
      ],
      "excerpt": "BertConfig - Configuration class to store the configuration of a BertModel with utilities to read and write from JSON configuration files. \nOpenAIGPTConfig - Configuration class to store the configuration of a OpenAIGPTModel with utilities to read and write from JSON configuration files. \nGPT2Config - Configuration class to store the configuration of a GPT2Model with utilities to read and write from JSON configuration files. \nTransfoXLConfig - Configuration class to store the configuration of a TransfoXLModel with utilities to read and write from JSON configuration files. \nThe repository further comprises: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8396202948635241,
        0.95040766011259,
        0.961030932144698,
        0.95040766011259,
        0.9409286061761132
      ],
      "excerpt": "extract_features.py - Show how to extract hidden states from an instance of BertModel, \nrun_classifier.py - Show how to fine-tune an instance of BertForSequenceClassification on GLUE's MRPC task, \nrun_squad.py - Show how to fine-tune an instance of BertForQuestionAnswering on SQuAD v1.0 and SQuAD v2.0 tasks. \nrun_swag.py - Show how to fine-tune an instance of BertForMultipleChoice on Swag task. \nsimple_lm_finetuning.py - Show how to fine-tune an instance of BertForPretraining on a target text corpus. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9624932768511073
      ],
      "excerpt": "run_openai_gpt.py - Show how to fine-tune an instance of OpenGPTDoubleHeadsModel on the RocStories task. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8962220368253133
      ],
      "excerpt": "run_transfo_xl.py - Show how to load and evaluate a pre-trained model of TransfoXLLMHeadModel on WikiText 103. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8262089452525654
      ],
      "excerpt": "Three notebooks that were used to check that the TensorFlow and PyTorch models behave identically (in the notebooks folder): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9108343303800355
      ],
      "excerpt": "Comparing-TF-and-PT-models-MLM-NSP.ipynb - Compare the predictions of the BertForPretraining instances. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9511931544033734
      ],
      "excerpt": "Here is a quick-start example using BertTokenizer, BertModel and BertForMaskedLM class with Google AI's pre-trained Bert base uncased model. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8422874512790841
      ],
      "excerpt": ": Mask a token that we will try to predict back with BertForMaskedLM \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9517389049682214
      ],
      "excerpt": ": Define sentence A and B indices associated to 1st and 2nd sentences (see paper) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8901041632873841
      ],
      "excerpt": "Let's see how to use BertModel to get hidden states \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = BertModel.from_pretrained('bert-base-uncased') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877,
        0.9552300800964612
      ],
      "excerpt": "    encoded_layers, _ = model(tokens_tensor, segments_tensors) \n: We have a hidden states for each of the 12 layers in model bert-base-uncased \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = BertForMaskedLM.from_pretrained('bert-base-uncased') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    predictions = model(tokens_tensor, segments_tensors) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9321013297742367
      ],
      "excerpt": "Here is a quick-start example using OpenAIGPTTokenizer, OpenAIGPTModel and OpenAIGPTLMHeadModel class with OpenAI's pre-trained  model. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8901041632873841
      ],
      "excerpt": "Let's see how to use OpenAIGPTModel to get hidden states \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = OpenAIGPTModel.from_pretrained('openai-gpt') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    hidden_states = model(tokens_tensor) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = OpenAIGPTLMHeadModel.from_pretrained('openai-gpt') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    predictions = model(tokens_tensor) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9507462696682489
      ],
      "excerpt": "Here is a quick-start example using TransfoXLTokenizer, TransfoXLModel and TransfoXLModelLMHeadModel class with the Transformer-XL model pre-trained on WikiText-103. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8901041632873841
      ],
      "excerpt": "Let's see how to use TransfoXLModel to get hidden states \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = TransfoXLModel.from_pretrained('transfo-xl-wt103') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    hidden_states_1, mems_1 = model(tokens_tensor_1) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    hidden_states_2, mems_2 = model(tokens_tensor_2, mems=mems_1) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = TransfoXLLMHeadModel.from_pretrained('transfo-xl-wt103') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    predictions_1, mems_1 = model(tokens_tensor_1) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    predictions_2, mems_2 = model(tokens_tensor_2, mems=mems_1) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9321013297742367
      ],
      "excerpt": "Here is a quick-start example using GPT2Tokenizer, GPT2Model and GPT2LMHeadModel class with OpenAI's pre-trained  model. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8901041632873841
      ],
      "excerpt": "Let's see how to use GPT2Model to get hidden states \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = GPT2Model.from_pretrained('gpt2') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    hidden_states_1, past = model(tokens_tensor_1) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    hidden_states_2, past = model(tokens_tensor_2, past=past) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = GPT2LMHeadModel.from_pretrained('gpt2') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    predictions_1, past = model(tokens_tensor_1) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "    predictions_2, past = model(tokens_tensor_2, past=past) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9581114993651744
      ],
      "excerpt": "Here is a detailed documentation of the classes in the package and how to use them: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9102791864450979,
        0.9782771009163006,
        0.9869193543448407,
        0.9334414658488187,
        0.9518880701368752,
        0.9788054077803701
      ],
      "excerpt": "| Serialization best-practices | How to save and reload a fine-tuned model | \n| Configurations | API of the configuration classes for BERT, GPT, GPT-2 and Transformer-XL | \n| Models | API of the PyTorch model classes for BERT, GPT, GPT-2 and Transformer-XL | \n| Tokenizers | API of the tokenizers class for BERT, GPT, GPT-2 and Transformer-XL| \n| Optimizers |  API of the optimizers | \nTo load one of Google AI's, OpenAI's pre-trained models or a PyTorch saved model (an instance of BertForPreTraining saved with torch.save()), the PyTorch model classes and the tokenizer can be instantiated as \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = BERT_CLASS.from_pretrained(PRE_TRAINED_MODEL_NAME_OR_PATH, cache_dir=None) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9370821047406508,
        0.9891785691729262
      ],
      "excerpt": "BERT_CLASS is either a tokenizer to load the vocabulary (BertTokenizer or OpenAIGPTTokenizer classes) or one of the eight BERT or three OpenAI GPT PyTorch model classes (to load the pre-trained weights): BertModel, BertForMaskedLM, BertForNextSentencePrediction, BertForPreTraining, BertForSequenceClassification, BertForTokenClassification, BertForMultipleChoice, BertForQuestionAnswering, OpenAIGPTModel, OpenAIGPTLMHeadModel or OpenAIGPTDoubleHeadsModel, and \nPRE_TRAINED_MODEL_NAME_OR_PATH is either: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8510338301519715,
        0.9264851007643321
      ],
      "excerpt": "bert_config.json or openai_gpt_config.json a configuration file for the model, and \npytorch_model.bin a PyTorch dump of a pre-trained instance of BertForPreTraining, OpenAIGPTModel, TransfoXLModel, GPT2LMHeadModel (saved with the usual torch.save()) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9909429711386981
      ],
      "excerpt": "Uncased means that the text has been lowercased before WordPiece tokenization, e.g., John Smith becomes john smith. The Uncased model also strips out any accent markers. Cased means that the true case and accent markers are preserved. Typically, the Uncased model is better unless you know that case information is important for your task (e.g., Named Entity Recognition or Part-of-Speech tagging). For information about the Multilingual and Chinese model, see the Multilingual README or the original TensorFlow repository. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = BertForSequenceClassification.from_pretrained('bert-base-uncased') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = OpenAIGPTModel.from_pretrained('openai-gpt') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = TransfoXLModel.from_pretrained('transfo-xl-wt103') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = GPT2Model.from_pretrained('gpt2') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.921032979771925
      ],
      "excerpt": "There are three types of files you need to save to be able to reload a fine-tuned model: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.967702446898555,
        0.9839492190538034,
        0.988467721917687
      ],
      "excerpt": "the configuration file of the model which is saved as a JSON file, and \nthe vocabulary (and the merges for the BPE-based models GPT and GPT-2). \nHere is the recommended way of saving the model, configuration and vocabulary to an output_dir directory and reloading the model and tokenizer afterwards: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8680855396521234,
        0.8382518941728377
      ],
      "excerpt": ": Step 1: Save a model, configuration and vocabulary that you have fine-tuned \n: If we have a distributed model, save only the encapsulated model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = BertForQuestionAnswering.from_pretrained(output_dir) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "model = OpenAIGPTDoubleHeadsModel.from_pretrained(output_dir) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8680855396521234,
        0.8382518941728377
      ],
      "excerpt": ": Step 1: Save a model, configuration and vocabulary that you have fine-tuned \n: If we have a distributed model, save only the encapsulated model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9541821628420976
      ],
      "excerpt": ": Here is how to do it in this situation: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.888412091102466,
        0.8886551524067641,
        0.8886551524067641,
        0.8886551524067641,
        0.8886551524067641,
        0.8804286566523759,
        0.9040511542705257,
        0.9058897788199143
      ],
      "excerpt": "Models (BERT, GPT, GPT-2 and Transformer-XL) are defined and build from configuration classes which containes the parameters of the models (number of layers, dimensionalities...) and a few utilities to read and write from JSON configuration files. The respective configuration classes are: \nBertConfig for BertModel and BERT classes instances. \nOpenAIGPTConfig for OpenAIGPTModel and OpenAI GPT classes instances. \nGPT2Config for GPT2Model and OpenAI GPT-2 classes instances. \nTransfoXLConfig for TransfoXLModel and Transformer-XL classes instances. \nThese configuration classes contains a few utilities to load and save configurations: \nfrom_dict(cls, json_object): A class method to construct a configuration from a Python dictionary of parameters. Returns an instance of the configuration class. \nfrom_json_file(cls, json_file): A class method to construct a configuration from a json file of parameters. Returns an instance of the configuration class. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9869361579805388,
        0.871763950162728
      ],
      "excerpt": "BertModel is the basic BERT Transformer model with a layer of summed token, position and sequence embeddings followed by a series of identical self-attention blocks (12 for BERT-base, 24 for BERT-large). \nThe inputs and output are identical to the TensorFlow model inputs and outputs. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8950006321051702,
        0.9804486745260436,
        0.9347082865991256
      ],
      "excerpt": "- input_ids: a torch.LongTensor of shape [batch_size, sequence_length] with the word token indices in the vocabulary (see the tokens preprocessing logic in the scripts extract_features.py, run_classifier.py and run_squad.py), and \n- token_type_ids: an optional torch.LongTensor of shape [batch_size, sequence_length] with the token types indices selected in [0, 1]. Type 0 corresponds to a sentence A and type 1 corresponds to a sentence B token (see BERT paper for more details). \n- attention_mask: an optional torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [0, 1]. It's a mask to be used if some input sequence lengths are smaller than the max input sequence length of the current batch. It's the mask that we typically use for attention when a batch has varying length sentences. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.955532050141774,
        0.8837026745377409,
        0.9826499988220441,
        0.9623442581210829,
        0.9896586349751337,
        0.8975984678009229
      ],
      "excerpt": "This model outputs a tuple composed of: \nencoded_layers: controled by the value of the output_encoded_layers argument: \noutput_all_encoded_layers=True: outputs a list of the encoded-hidden-states at the end of each attention block (i.e. 12 full sequences for BERT-base, 24 for BERT-large), each encoded-hidden-state is a torch.FloatTensor of size [batch_size, sequence_length, hidden_size], \noutput_all_encoded_layers=False: outputs only the encoded-hidden-states corresponding to the last attention block, i.e. a single torch.FloatTensor of size [batch_size, sequence_length, hidden_size], \npooled_output: a torch.FloatTensor of size [batch_size, hidden_size] which is the output of a classifier pretrained on top of the hidden state associated to the first character of the input (CLF) to train on the Next-Sentence task (see BERT's paper). \nAn example on how to use this class is given in the extract_features.py script which can be used to extract the hidden states of the model for a given input. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8137010051353408
      ],
      "excerpt": "the masked language modeling head, and \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9569729956108128,
        0.9665572897097536
      ],
      "excerpt": "masked_lm_labels: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size] \nnext_sentence_label: next sentence classification loss: torch.LongTensor of shape [batch_size] with indices selected in [0, 1]. 0 => next sentence is the continuation, 1 => next sentence is a random sentence. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9483570363286061
      ],
      "excerpt": "if masked_lm_labels and next_sentence_label are not None: Outputs the total_loss which is the sum of the masked language modeling loss and the next sentence classification loss. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8699247168531064
      ],
      "excerpt": "the masked language modeling logits, and \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.941466651848009
      ],
      "excerpt": "An example on how to use this class is given in the run_lm_finetuning.py script which can be used to fine-tune the BERT language model on your specific different text corpus. This should improve model performance, if the language style is different from the original BERT training corpus (Wiki + BookCorpus). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9569729956108128
      ],
      "excerpt": "masked_lm_labels: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size] \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9665572897097536
      ],
      "excerpt": "next_sentence_label: next sentence classification loss: torch.LongTensor of shape [batch_size] with indices selected in [0, 1]. 0 => next sentence is the continuation, 1 => next sentence is a random sentence. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9875424135013634,
        0.9529803923901541,
        0.9247087018176084,
        0.9912069416656832,
        0.9414230577600494,
        0.9849927456656524,
        0.8525077059113418,
        0.9936916514155753,
        0.9624807996776111,
        0.9964126259941694,
        0.9861465112708021,
        0.8546417448808448,
        0.9802539037106949
      ],
      "excerpt": "BertForSequenceClassification is a fine-tuning model that includes BertModel and a sequence-level (sequence or pair of sequences) classifier on top of the BertModel. \nThe sequence-level classifier is a linear layer that takes as input the last hidden state of the first character in the input sequence (see Figures 3a and 3b in the BERT paper). \nAn example on how to use this class is given in the run_classifier.py script which can be used to fine-tune a single sequence (or pair of sequence) classifier using BERT, for example for the MRPC task. \nBertForMultipleChoice is a fine-tuning model that includes BertModel and a linear layer on top of the BertModel. \nThe linear layer outputs a single value for each choice of a multiple choice problem, then all the outputs corresponding to an instance are passed through a softmax to get the model choice. \nThis implementation is largely inspired by the work of OpenAI in Improving Language Understanding by Generative Pre-Training and the answer of Jacob Devlin in the following issue. \nAn example on how to use this class is given in the run_swag.py script which can be used to fine-tune a multiple choice classifier using BERT, for example for the Swag task. \nBertForTokenClassification is a fine-tuning model that includes BertModel and a token-level classifier on top of the BertModel. \nThe token-level classifier is a linear layer that takes as input the last hidden state of the sequence. \nBertForQuestionAnswering is a fine-tuning model that includes BertModel with a token-level classifiers on top of the full sequence of last hidden states. \nThe token-level classifier takes as input the full sequence of the last hidden state and compute several (e.g. two) scores for each tokens that can for example respectively be the score that a given token is a start_span and a end_span token (see Figures 3c and 3d in the BERT paper). \nAn example on how to use this class is given in the run_squad.py script which can be used to fine-tune a token classifier using BERT, for example for the SQuAD task. \nOpenAIGPTModel is the basic OpenAI GPT Transformer model with a layer of summed token and position embeddings followed by a series of 12 identical self-attention blocks. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.871763950162728
      ],
      "excerpt": "The inputs and output are identical to the TensorFlow model inputs and outputs. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9499910962200462
      ],
      "excerpt": "- input_ids: a torch.LongTensor of shape [batch_size, sequence_length] (or more generally [d_1, ..., d_n, sequence_length] were d_1 ... d_n are arbitrary dimensions) with the word BPE token indices selected in the range [0, total_tokens_embeddings[ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9914233350357525,
        0.9177957082734539
      ],
      "excerpt": "- hidden_states: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, hidden_size] (or more generally [d_1, ..., d_n, hidden_size] were d_1 ... d_n are the dimension of input_ids) \nOpenAIGPTLMHeadModel includes the OpenAIGPTModel Transformer followed by a language modeling head with weights tied to the input embeddings (no additional parameters). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9419176120627517
      ],
      "excerpt": "- lm_labels: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9766396231453992
      ],
      "excerpt": "  Outputs lm_logits: the language modeling logits as a torch.FloatTensor of size [batch_size, sequence_length, total_tokens_embeddings] (or more generally [d_1, ..., d_n, total_tokens_embeddings] were d_1 ... d_n are the dimension of input_ids) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9072298229113102,
        0.9232329570932
      ],
      "excerpt": "- a language modeling head with weights tied to the input embeddings (no additional parameters) and: \n- a multiple choice classifier (linear layer that take as input a hidden state in a sequence to compute a score, see details in paper). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9130136057399877,
        0.9419176120627517
      ],
      "excerpt": "- multiple_choice_token_ids: a torch.LongTensor of shape [batch_size, num_choices] with the index of the token whose hidden state should be used as input for the multiple choice classifier (usually the [CLS] token for each choice). \n- lm_labels: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9313262888045455,
        0.8065882974910986,
        0.9247606160706361,
        0.8842336096794167,
        0.958773758297031
      ],
      "excerpt": "  Outputs a tuple of losses with the language modeling loss and the multiple choice loss. \n- else Outputs a tuple with: \n  - lm_logits: the language modeling logits as a torch.FloatTensor of size [batch_size, num_choices, sequence_length, total_tokens_embeddings] \n  - multiple_choice_logits: the multiple choice logits as a torch.FloatTensor of size [batch_size, num_choices] \nThe Transformer-XL model is described in \"Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context\". \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9714869099973962
      ],
      "excerpt": "the tokens in the vocabulary have to be sorted to decreasing frequency. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8428600376057017
      ],
      "excerpt": "- input_ids: a torch.LongTensor of shape [batch_size, sequence_length] with the token indices selected in the range [0, self.config.n_token[ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.955532050141774,
        0.9541939315307151,
        0.8443936723735986,
        0.9785554815069424,
        0.9703541771787467
      ],
      "excerpt": "This model outputs a tuple of (last_hidden_state, new_mems) \n- last_hidden_state: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, self.config.d_model] \n- new_mems: list (num layers) of updated mem states at the entry of each layer each mem state is a torch.FloatTensor of size [self.config.mem_len, batch_size, self.config.d_model]. Note that the first two dimensions are transposed in mems with regards to input_ids. \nThe new_mems contain all the hidden states PLUS the output of the embeddings (new_mems[0]). new_mems[-1] is the output of the hidden state of the layer below the last layer and last_hidden_state is the output of the last layer (i.E. the input of the softmax when we have a language modeling head on top). \nThere are two differences between the shapes of new_mems and last_hidden_state: new_mems have transposed first dimensions and are longer (of size self.config.mem_len). Here is how to extract the full list of hidden states from the model output: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "hidden_states, mems = model(tokens_tensor) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8405860765054796
      ],
      "excerpt": "lower_hidden_states = list(t[-seq_length:, ...].transpose(0, 1) for t in mems) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8211100285345944
      ],
      "excerpt": "TransfoXLLMHeadModel includes the TransfoXLModel Transformer followed by an (adaptive) softmax head with weights tied to the input embeddings. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9019425290223541
      ],
      "excerpt": "Outputs a tuple of (last_hidden_state, new_mems) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8661912954142521,
        0.8443936723735986,
        0.9845820424584654,
        0.871763950162728
      ],
      "excerpt": "  - else: Negative log likelihood of target tokens with shape [batch_size, sequence_length] \n- new_mems: list (num layers) of updated mem states at the entry of each layer each mem state is a torch.FloatTensor of size [self.config.mem_len, batch_size, self.config.d_model]. Note that the first two dimensions are transposed in mems with regards to input_ids. \nGPT2Model is the OpenAI GPT-2 Transformer model with a layer of summed token and position embeddings followed by a series of 12 identical self-attention blocks. \nThe inputs and output are identical to the TensorFlow model inputs and outputs. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9499910962200462
      ],
      "excerpt": "- input_ids: a torch.LongTensor of shape [batch_size, sequence_length] (or more generally [d_1, ..., d_n, sequence_length] were d_1 ... d_n are arbitrary dimensions) with the word BPE token indices selected in the range [0, vocab_size[ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9762242726340311
      ],
      "excerpt": "- past: an optional list of torch.LongTensor that contains pre-computed hidden-states (key and values in the attention blocks) to speed up sequential decoding (this is the presents output of the model, cf. below). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9914233350357525
      ],
      "excerpt": "- hidden_states: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, hidden_size] (or more generally [d_1, ..., d_n, hidden_size] were d_1 ... d_n are the dimension of input_ids) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9177957082734539
      ],
      "excerpt": "GPT2LMHeadModel includes the GPT2Model Transformer followed by a language modeling head with weights tied to the input embeddings (no additional parameters). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9419176120627517
      ],
      "excerpt": "- lm_labels: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9968029537584643,
        0.9787228327251541
      ],
      "excerpt": "- else: a tuple of \n  - lm_logits: the language modeling logits as a torch.FloatTensor of size [batch_size, sequence_length, total_tokens_embeddings] (or more generally [d_1, ..., d_n, total_tokens_embeddings] were d_1 ... d_n are the dimension of input_ids) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9072298229113102,
        0.9232329570932
      ],
      "excerpt": "- a language modeling head with weights tied to the input embeddings (no additional parameters) and: \n- a multiple choice classifier (linear layer that take as input a hidden state in a sequence to compute a score, see details in paper). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9130136057399877,
        0.9419176120627517
      ],
      "excerpt": "- multiple_choice_token_ids: a torch.LongTensor of shape [batch_size, num_choices] with the index of the token whose hidden state should be used as input for the multiple choice classifier (usually the [CLS] token for each choice). \n- lm_labels: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9313262888045455,
        0.8065882974910986,
        0.9247606160706361,
        0.8842336096794167
      ],
      "excerpt": "  Outputs a tuple of losses with the language modeling loss and the multiple choice loss. \n- else Outputs a tuple with: \n  - lm_logits: the language modeling logits as a torch.FloatTensor of size [batch_size, num_choices, sequence_length, total_tokens_embeddings] \n  - multiple_choice_logits: the multiple choice logits as a torch.FloatTensor of size [batch_size, num_choices] \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8266877417631755
      ],
      "excerpt": "BertTokenizer perform end-to-end tokenization, i.e. basic tokenization followed by WordPiece tokenization. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8507494215418435
      ],
      "excerpt": "max_len: max length to filter the input of the Transformer. Default to pre-trained value for the model if None. Default = None \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9283447886271797,
        0.9416800147346274,
        0.9416800147346274
      ],
      "excerpt": "tokenize(text): convert a str in a list of str tokens by (1) performing basic tokenization and (2) WordPiece tokenization. \nconvert_tokens_to_ids(tokens): convert a list of str tokens in a list of int indices in the vocabulary. \nconvert_ids_to_tokens(tokens): convert a list of int indices in a list of str tokens in the vocabulary. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9611126641579039
      ],
      "excerpt": "Please refer to the doc strings and code in tokenization.py for the details of the BasicTokenizer and WordpieceTokenizer classes. In general it is recommended to use BertTokenizer unless you know what you are doing. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8507494215418435,
        0.9762059403745099
      ],
      "excerpt": "max_len: max length to filter the input of the Transformer. Default to pre-trained value for the model if None. Default = None \nspecial_tokens: a list of tokens to add to the vocabulary for fine-tuning. If SpaCy is not installed and BERT's BasicTokenizer is used as the pre-BPE tokenizer, these tokens are not split. Default= None \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9345427721058283,
        0.9416800147346274,
        0.9416800147346274,
        0.9270976845904256,
        0.9345427721058283
      ],
      "excerpt": "tokenize(text): convert a str in a list of str tokens by performing BPE tokenization. \nconvert_tokens_to_ids(tokens): convert a list of str tokens in a list of int indices in the vocabulary. \nconvert_ids_to_tokens(tokens): convert a list of int indices in a list of str tokens in the vocabulary. \nset_special_tokens(self, special_tokens): update the list of special tokens (see above arguments) \nencode(text): convert a str in a list of int tokens by performing BPE encoding. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9826254281141776,
        0.8584550753806509,
        0.9818419106201965,
        0.9832737443363584
      ],
      "excerpt": "Please refer to the doc strings and code in tokenization_openai.py for the details of the OpenAIGPTTokenizer. \nTransfoXLTokenizer perform word tokenization. This tokenizer can be used for adaptive softmax and has utilities for counting tokens in a corpus to create a vocabulary ordered by toekn frequency (for adaptive softmax). See the adaptive softmax paper (Efficient softmax approximation for GPUs) for more details. \nThe API is similar to the API of BertTokenizer (see above). \nPlease refer to the doc strings and code in tokenization_transfo_xl.py for the details of these additional methods in TransfoXLTokenizer. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9115660947207741,
        0.9416800147346274,
        0.9416800147346274,
        0.9270976845904256,
        0.9115660947207741,
        0.8931087924941753
      ],
      "excerpt": "tokenize(text): convert a str in a list of str tokens by performing byte-level BPE. \nconvert_tokens_to_ids(tokens): convert a list of str tokens in a list of int indices in the vocabulary. \nconvert_ids_to_tokens(tokens): convert a list of int indices in a list of str tokens in the vocabulary. \nset_special_tokens(self, special_tokens): update the list of special tokens (see above arguments) \nencode(text): convert a str in a list of int tokens by performing byte-level BPE. \ndecode(tokens): convert back a list of int tokens in a str. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9542548220953166,
        0.9901358241330641
      ],
      "excerpt": "Please refer to tokenization_gpt2.py for more details on the GPT2Tokenizer. \nBertAdam is a torch.optimizer adapted to be closer to the optimizer used in the TensorFlow implementation of Bert. The differences with PyTorch Adam optimizer are the following: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8805492520991454
      ],
      "excerpt": "BertAdam doesn't compensate for bias as in the regular Adam optimizer. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9003086186204077
      ],
      "excerpt": "warmup : portion of t_total for the warmup, -1  means no warmup. Default : -1 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.918633471929804
      ],
      "excerpt": "schedule : schedule to use for the warmup (see above). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9701199240976869,
        0.9916356522620997
      ],
      "excerpt": "OpenAIAdam is similar to BertAdam. \nThe differences with BertAdam is that OpenAIAdam compensate for bias as in the regular Adam optimizer. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9742269605447247,
        0.855739339323458,
        0.9031129067453986,
        0.930032167166361,
        0.9452196480255554
      ],
      "excerpt": "The .optimization module also provides additional schedules in the form of schedule objects that inherit from _LRSchedule. \nAll _LRSchedule subclasses accept warmup and t_total arguments at construction. \nWhen an _LRSchedule object is passed into BertAdam or OpenAIAdam,  \nthe warmup and t_total arguments on the optimizer are ignored and the ones in the _LRSchedule object are used.  \nAn overview of the implemented schedules: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.815132685428197
      ],
      "excerpt": "- WarmupConstantSchedule: Linearly increases learning rate from 0 to 1 over warmup fraction of training steps. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.815132685428197
      ],
      "excerpt": "- WarmupLinearSchedule: Linearly increases learning rate from 0 to 1 over warmup fraction of training steps. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.815132685428197
      ],
      "excerpt": "-  WarmupCosineSchedule: Linearly increases learning rate from 0 to 1 over warmup fraction of training steps. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.815132685428197
      ],
      "excerpt": "- WarmupCosineWithHardRestartsSchedule: Linearly increases learning rate from 0 to 1 over warmup fraction of training steps. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8917624817406069,
        0.8259323582600668
      ],
      "excerpt": "- WarmupCosineWithWarmupRestartsSchedule: All training progress is divided in cycles (default=1.) parts of equal length. \n    Every part follows a schedule with the first warmup fraction of the training steps linearly increasing from 0. to 1., \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9288835798863088
      ],
      "excerpt": "    Note that the total number of all warmup steps over all cycles together is equal to warmup * cycles \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8457141015217677
      ],
      "excerpt": "Corpus (MRPC) corpus and runs in less than 10 minutes on a single K-80 and in 27 seconds (!) on single tesla V100 16GB with apex installed. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8650815684719652
      ],
      "excerpt": "Our test ran on a few seeds with the original implementation hyper-parameters gave evaluation results between 84% and 88%. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9552463116303516
      ],
      "excerpt": "This example code fine-tunes BERT on the SQuAD dataset. It runs in 24 min (with BERT-base) or 68 min (with BERT-large) on a single tesla V100 16GB. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8481310065455568
      ],
      "excerpt": "The data for SWAG can be downloaded by cloning the following repository \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8979411005071259
      ],
      "excerpt": "  --data_dir $SWAG_DIR/data \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9833863672912803
      ],
      "excerpt": "Thank to the work of @Rocketknight1 and @tholor there are now several scripts that can be used to fine-tune BERT using the pretraining objective (combination of masked-language modeling and next sentence prediction loss). These scripts are detailed in the README of the examples/lm_finetuning/ folder. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9653739014924488
      ],
      "excerpt": "This command runs in about 10 min on a single K-80 an gives an evaluation accuracy of about 87.7% (the authors report a median accuracy with the TensorFlow code of 85.8% and the OpenAI GPT paper reports a best single run accuracy of 86.5%). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9663354414350628,
        0.9017926453722093
      ],
      "excerpt": "This command runs in about 1 min on a V100 and gives an evaluation perplexity of 18.22 on WikiText-103 (the authors report a perplexity of about 18.3 on this dataset with the TensorFlow code). \nThis example code is identical to the original unconditional and conditional generation codes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9521280130475316,
        0.9680624556996875,
        0.9692769278841723
      ],
      "excerpt": "The same option as in the original scripts are provided, please refere to the code of the example and the original repository of OpenAI. \nThe options we list above allow to fine-tune BERT-large rather easily on GPU(s) instead of the TPU used by the original implementation. \nFor example, fine-tuning BERT-large on SQuAD can be done on a server with 4 k-80 (these are pretty old now) in 18 hours. Our results are similar to the TensorFlow implementation results (actually slightly higher): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9800015342891558
      ],
      "excerpt": "To get these results we used a combination of: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8470727218428329,
        0.8656306372862254,
        0.9219292980038031
      ],
      "excerpt": "- 2 steps of gradient accumulation and \n- perform the optimization step on CPU to store Adam's averages in RAM. \nHere is the full list of hyper-parameters for this run: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8263071291011903
      ],
      "excerpt": "Here is an example of hyper-parameters for a FP16 run we tried: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8000418664789859
      ],
      "excerpt": "The results were similar to the above FP32 results (actually slightly higher): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9898279673264107,
        0.9780348483205501,
        0.9713498171230884,
        0.9475399943738184
      ],
      "excerpt": "We include three Jupyter Notebooks that can be used to check that the predictions of the PyTorch model are identical to the predictions of the original TensorFlow model. \nThe first NoteBook (Comparing-TF-and-PT-models.ipynb) extracts the hidden states of a full sequence on each layers of the TensorFlow and the PyTorch models and computes the standard deviation between them. In the given example, we get a standard deviation of 1.5e-7 to 9e-7 on the various hidden state of the models. \nThe second NoteBook (Comparing-TF-and-PT-models-SQuAD.ipynb) compares the loss computed by the TensorFlow and the PyTorch models for identical initialization of the fine-tuning layer of the BertForQuestionAnswering and computes the standard deviation between them. In the given example, we get a standard deviation of 2.5e-7 between the models. \nThe third NoteBook (Comparing-TF-and-PT-models-MLM-NSP.ipynb) compares the predictions computed by the TensorFlow and the PyTorch models for masked token language modeling using the pre-trained masked language modeling model. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8074060052830431
      ],
      "excerpt": "A command-line interface is provided to convert a TensorFlow checkpoint in a PyTorch dump of the BertForPreTraining class  (for BERT) or NumPy checkpoint in a PyTorch dump of the OpenAIGPTModel class  (for OpenAI GPT). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9398187351731951,
        0.8721331729062989
      ],
      "excerpt": "This CLI takes as input a TensorFlow checkpoint (three files starting with bert_model.ckpt) and the associated configuration file (bert_config.json), and creates a PyTorch model for this configuration, loads the weights from the TensorFlow checkpoint in the PyTorch model and saves the resulting model in a standard PyTorch save file that can be imported using torch.load() (see examples in extract_features.py, run_classifier.py and run_squad.py). \nYou only need to run this conversion script once to get a PyTorch model. You can then disregard the TensorFlow checkpoint (the three files starting with bert_model.ckpt) but be sure to keep the configuration file (bert_config.json) and the vocabulary file (vocab.txt) as these are needed for the PyTorch model too. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.927285039780152
      ],
      "excerpt": "Here is an example of the conversion process for a pre-trained BERT-Base Uncased model: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9234337451571722
      ],
      "excerpt": "Here is an example of the conversion process for a pre-trained OpenAI GPT model, assuming that your NumPy checkpoint save as the same format than OpenAI pretrained model (see here) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9286742141281934
      ],
      "excerpt": "Here is an example of the conversion process for a pre-trained Transformer-XL model (see here) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.927285039780152
      ],
      "excerpt": "Here is an example of the conversion process for a pre-trained OpenAI's GPT-2 model. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.860059181823877
      ],
      "excerpt": "  $GPT2_DIR/model.ckpt \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9758817721218083,
        0.8862102677216092
      ],
      "excerpt": "TPU are not supported by the current stable release of PyTorch (0.4.1). However, the next version of PyTorch (v1.0) should support training on TPU and is expected to be released soon (see the recent official announcement). \nWe will add TPU support when this next release is published. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        1.0
      ],
      "excerpt": "PyTorch version of Google AI's BERT model with script to load Google's pre-trained models",
      "technique": "GitHub API"
    }
  ],
  "downloadUrl": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/cedrickchee/pytorch-pretrained-BERT/releases",
    "technique": "GitHub API"
  },
  "forks_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 3,
      "date": "Thu, 23 Dec 2021 10:02:17 GMT"
    },
    "technique": "GitHub API"
  },
  "forks_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/cedrickchee/pytorch-pretrained-BERT/forks",
    "technique": "GitHub API"
  },
  "fullName": {
    "confidence": [
      1.0
    ],
    "excerpt": "cedrickchee/pytorch-pretrained-BERT",
    "technique": "GitHub API"
  },
  "hasBuildFile": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://raw.githubusercontent.com/cedrickchee/pytorch-pretrained-BERT/master/docker/Dockerfile"
    ],
    "technique": "File Exploration"
  },
  "hasDocumentation": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://github.com/cedrickchee/pytorch-pretrained-BERT/tree/master/docs"
    ],
    "technique": "File Exploration"
  },
  "hasExecutableNotebook": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "https://raw.githubusercontent.com/cedrickchee/pytorch-pretrained-BERT/master/notebooks/Comparing-TF-and-PT-models-SQuAD.ipynb",
      "https://raw.githubusercontent.com/cedrickchee/pytorch-pretrained-BERT/master/notebooks/Comparing-TF-and-PT-models.ipynb",
      "https://raw.githubusercontent.com/cedrickchee/pytorch-pretrained-BERT/master/notebooks/Comparing-TF-and-PT-models-MLM-NSP.ipynb"
    ],
    "technique": "File Exploration"
  },
  "installation": [
    {
      "confidence": [
        1
      ],
      "excerpt": "We get the following results on the dev set of GLUE benchmark with an uncased BERT base \nmodel. All experiments were run on a P100 GPU with a batch size of 32.\n\n| Task | Metric | Result |\n|-|-|-|\n| CoLA | Matthew's corr. | 57.29 |\n| SST-2 | accuracy | 93.00 |\n| MRPC | F1/accuracy | 88.85/83.82 |\n| STS-B | Pearson/Spearman corr. | 89.70/89.37 |\n| QQP | accuracy/F1 | 90.72/87.41 |\n| MNLI | matched acc./mismatched acc.| 83.95/84.39 |\n| QNLI | accuracy | 89.04 |\n| RTE | accuracy | 61.01 |\n| WNLI | accuracy | 53.52 |\n\nSome of these results are significantly different from the ones reported on the test set\nof GLUE benchmark on the website. For QQP and WNLI, please refer to [FAQ #12](https://gluebenchmark.com/faq) on the webite.\n\nBefore running anyone of these GLUE tasks you should download the\n[GLUE data](https://gluebenchmark.com/tasks) by running\n[this script](https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e)\nand unpack it to some directory `$GLUE_DIR`.\n\n```shell\nexport GLUE_DIR=/path/to/glue\nexport TASK_NAME=MRPC\n\npython run_classifier.py \\\n  --task_name $TASK_NAME \\\n  --do_train \\\n  --do_eval \\\n  --do_lower_case \\\n  --data_dir $GLUE_DIR/$TASK_NAME \\\n  --bert_model bert-base-uncased \\\n  --max_seq_length 128 \\\n  --train_batch_size 32 \\\n  --learning_rate 2e-5 \\\n  --num_train_epochs 3.0 \\\n  --output_dir /tmp/$TASK_NAME/\n```\n\nwhere task name can be one of CoLA, SST-2, MRPC, STS-B, QQP, MNLI, QNLI, RTE, WNLI.\n\nThe dev set results will be present within the text file 'eval_results.txt' in the specified output_dir. In case of MNLI, since there are two separate dev sets, matched and mismatched, there will be a separate output folder called '/tmp/MNLI-MM/' in addition to '/tmp/MNLI/'.\n\nThe code has not been tested with half-precision training with apex on any GLUE task apart from MRPC, MNLI, CoLA, SST-2. The following section provides details on how to run half-precision training with MRPC. With that being said, there shouldn't be any issues in running half-precision training with the remaining GLUE tasks as well, since the data processor for each task inherits from the base class DataProcessor.\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        1
      ],
      "excerpt": "This repo was tested on Python 2.7 and 3.5+ (examples are tested only on python 3.5+) and PyTorch 0.4.1/1.0.0\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        0.9910659893881812
      ],
      "excerpt": "| Installation | How to install the package | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9709706075148068,
        0.9995486579735738,
        0.872459662279921,
        0.999746712887969,
        0.9278267262953355
      ],
      "excerpt": "PyTorch pretrained bert can be installed by pip as follows: \npip install pytorch-pretrained-bert \nIf you want to reproduce the original tokenization process of the OpenAI GPT paper, you will need to install ftfy (limit to version 4.4.3 if you are using Python 2) and SpaCy : \npip install spacy ftfy==4.4.3 \npython -m spacy download en \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9855251805776313,
        0.8788933026153585,
        0.999746712887969,
        0.9278267262953355
      ],
      "excerpt": "pip install [--editable] . \nHere also, if you want to reproduce the original tokenization process of the OpenAI GPT model, you will need to install ftfy (limit to version 4.4.3 if you are using Python 2) and SpaCy : \npip install spacy ftfy==4.4.3 \npython -m spacy download en \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9439158599445541,
        0.9126015828715202
      ],
      "excerpt": "A series of tests is included in the tests folder and can be run using pytest (install pytest if needed: pip install pytest). \nYou can run the tests with the command: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor = tokens_tensor.to('cuda') \nsegments_tensors = segments_tensors.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor = tokens_tensor.to('cuda') \nsegments_tensors = segments_tensors.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor = tokens_tensor.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor = tokens_tensor.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8189886795368755
      ],
      "excerpt": ": get the predicted last token \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor_1 = tokens_tensor_1.to('cuda') \ntokens_tensor_2 = tokens_tensor_2.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor_1 = tokens_tensor_1.to('cuda') \ntokens_tensor_2 = tokens_tensor_2.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8189886795368755
      ],
      "excerpt": ": get the predicted last token \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor_1 = tokens_tensor_1.to('cuda') \ntokens_tensor_2 = tokens_tensor_2.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.936149002183157,
        0.8135918473277404,
        0.8135918473277404
      ],
      "excerpt": ": If you have a GPU, put everything on cuda \ntokens_tensor_1 = tokens_tensor_1.to('cuda') \ntokens_tensor_2 = tokens_tensor_2.to('cuda') \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8189886795368755
      ],
      "excerpt": ": get the predicted last token \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8078556051701942
      ],
      "excerpt": "If PRE_TRAINED_MODEL_NAME_OR_PATH is a shortcut name, the pre-trained weights will be downloaded from AWS S3 (see the links here) and stored in a cache folder to avoid future download (the cache folder can be found at ~/.pytorch_pretrained_bert/). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8402629498189389
      ],
      "excerpt": "schedule : schedule to use for the warmup (see above). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8123918214965836
      ],
      "excerpt": "First install apex as indicated here. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8349509675516925
      ],
      "excerpt": "The data for SQuAD can be downloaded with the following links and should be saved in a $SQUAD_DIR directory. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.839193676928051
      ],
      "excerpt": "This command will download a pre-processed version of the WikiText 103 dataset in which the vocabulary has been computed. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.917225505840189
      ],
      "excerpt": "If you have a recent GPU (starting from NVIDIA Volta series), you should try 16-bit fine-tuning (FP16). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9571273313566925
      ],
      "excerpt": "To run this specific conversion script you will need to have TensorFlow and PyTorch installed (pip install tensorflow). The rest of the repository only requires PyTorch. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8419035471514656
      ],
      "excerpt": "export OPENAI_GPT_CHECKPOINT_FOLDER_PATH=/path/to/openai/pretrained/numpy/weights \n",
      "technique": "Supervised classification"
    }
  ],
  "invocation": [
    {
      "confidence": [
        0.8903561003989042
      ],
      "excerpt": "| Usage | Quickstart examples | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.800387976012441
      ],
      "excerpt": "| Command-line interface | Convert a TensorFlow checkpoint in a PyTorch dump | \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8377922368335261
      ],
      "excerpt": "python -m spacy download en \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8377922368335261
      ],
      "excerpt": "python -m spacy download en \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8630645762968261
      ],
      "excerpt": "python -m pytest -sv tests/ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8557871367155505
      ],
      "excerpt": "Tokenizers for BERT (using word-piece) (in the tokenization.py file): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8969110041754327
      ],
      "excerpt": "Optimizer for OpenAI GPT (in the optimization_openai.py file): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8010294479814858
      ],
      "excerpt": "Configuration classes for BERT, OpenAI GPT and Transformer-XL (in the respective modeling.py, modeling_openai.py, modeling_transfo_xl.py files): \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8459456289743279,
        0.8559944927258344,
        0.8041125598517358
      ],
      "excerpt": "Five examples on how to use BERT (in the examples folder): \nextract_features.py - Show how to extract hidden states from an instance of BertModel, \nrun_classifier.py - Show how to fine-tune an instance of BertForSequenceClassification on GLUE's MRPC task, \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8041125598517358,
        0.8486153997036757,
        0.8721627651093772,
        0.8004066471921826,
        0.8721627651093772,
        0.8536666744123389,
        0.8078397268358504,
        0.9206049441871861
      ],
      "excerpt": "run_swag.py - Show how to fine-tune an instance of BertForMultipleChoice on Swag task. \nsimple_lm_finetuning.py - Show how to fine-tune an instance of BertForPretraining on a target text corpus. \nOne example on how to use OpenAI GPT (in the examples folder): \nrun_openai_gpt.py - Show how to fine-tune an instance of OpenGPTDoubleHeadsModel on the RocStories task. \nOne example on how to use Transformer-XL (in the examples folder): \nrun_transfo_xl.py - Show how to load and evaluate a pre-trained model of TransfoXLLMHeadModel on WikiText 103. \nOne example on how to use OpenAI GPT-2 in the unconditional and interactive mode (in the examples folder): \nrun_gpt2.py - Show how to use OpenAI GPT-2 an instance of GPT2LMHeadModel to generate text (same as the original OpenAI GPT-2 examples). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8801854956928516
      ],
      "excerpt": "from pytorch_pretrained_bert import BertTokenizer, BertModel, BertForMaskedLM \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8177137148100153
      ],
      "excerpt": "import logging \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8359299706379749
      ],
      "excerpt": "tokenized_text = tokenizer.tokenize(text) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8409662746899998
      ],
      "excerpt": "Here is a quick-start example using OpenAIGPTTokenizer, OpenAIGPTModel and OpenAIGPTLMHeadModel class with OpenAI's pre-trained  model. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8801854956928516
      ],
      "excerpt": "from pytorch_pretrained_bert import OpenAIGPTTokenizer, OpenAIGPTModel, OpenAIGPTLMHeadModel \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8177137148100153
      ],
      "excerpt": "import logging \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8359299706379749
      ],
      "excerpt": "tokenized_text = tokenizer.tokenize(text) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8221029311215009
      ],
      "excerpt": "Here is a quick-start example using TransfoXLTokenizer, TransfoXLModel and TransfoXLModelLMHeadModel class with the Transformer-XL model pre-trained on WikiText-103. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8801854956928516
      ],
      "excerpt": "from pytorch_pretrained_bert import TransfoXLTokenizer, TransfoXLModel, TransfoXLLMHeadModel \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8177137148100153
      ],
      "excerpt": "import logging \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8409662746899998
      ],
      "excerpt": "Here is a quick-start example using GPT2Tokenizer, GPT2Model and GPT2LMHeadModel class with OpenAI's pre-trained  model. See the doc section below for all the details on these classes. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8801854956928516
      ],
      "excerpt": "from pytorch_pretrained_bert import GPT2Tokenizer, GPT2Model, GPT2LMHeadModel \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8177137148100153
      ],
      "excerpt": "import logging \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9094880934938958
      ],
      "excerpt": "    #: (see beam-search examples in the run_gpt2.py example). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9094880934938958
      ],
      "excerpt": "    #: (see beam-search examples in the run_gpt2.py example). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.847394650410687
      ],
      "excerpt": "a path or url to a pretrained model archive containing: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.813163493354007
      ],
      "excerpt": "tokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case=True, do_basic_tokenize=True) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8801854956928516
      ],
      "excerpt": "from pytorch_pretrained_bert import WEIGHTS_NAME, CONFIG_NAME \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8519085199315721
      ],
      "excerpt": ": Example for a Bert model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8519085199315721
      ],
      "excerpt": ": Example for a GPT model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8519085199315721
      ],
      "excerpt": ": Example for a Bert model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8519085199315721
      ],
      "excerpt": ": Example for a GPT model \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8583960095951245
      ],
      "excerpt": "to_json_file(json_file_path): Save an instance to a json file. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8019644770030332,
        0.8710323007644651
      ],
      "excerpt": "vocab_file: path to a vocabulary file. \ndo_lower_case: convert text to lower-case while tokenizing. Default = True. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8463051018856345
      ],
      "excerpt": "do_basic_tokenize: Do basic tokenization before wordpice tokenization. Set to false if text is pre-tokenized. Default = True. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8264278960708686
      ],
      "excerpt": "tokenize(text): convert a str in a list of str tokens by (1) performing basic tokenization and (2) WordPiece tokenization. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8019644770030332,
        0.8063746948455133
      ],
      "excerpt": "vocab_file: path to a vocabulary file. \nmerges_file: path to a file containing the BPE merges. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8019644770030332,
        0.8063746948455133
      ],
      "excerpt": "vocab_file: path to a vocabulary file. \nmerges_file: path to a file containing the BPE merges. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8793559361076495
      ],
      "excerpt": "weight_decay: Weight decay. Default : 0.01 \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_classifier.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8117007451991057
      ],
      "excerpt": "Then run \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_classifier.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_squad.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8445146240188418
      ],
      "excerpt": "  --train_file $SQUAD_DIR/train-v1.1.json \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_swag.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9399753113789856
      ],
      "excerpt": "The data should be a text file in the same format as sample_text.txt  (one sentence per line, docs separated by empty line). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_openai_gpt.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8936822600874673
      ],
      "excerpt": "python run_transfo_xl.py --work_dir ../log \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_gpt2.py \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python run_gpt2.py --unconditional \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python ./run_squad.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8445146240188418
      ],
      "excerpt": "  --train_file $SQUAD_DIR/train-v1.1.json \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9246227682586091
      ],
      "excerpt": "python ./run_squad.py \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8445146240188418
      ],
      "excerpt": "  --train_file $SQUAD_DIR/train-v1.1.json \\ \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.851018866743008
      ],
      "excerpt": "This CLI takes as input a TensorFlow checkpoint (three files starting with bert_model.ckpt) and the associated configuration file (bert_config.json), and creates a PyTorch model for this configuration, loads the weights from the TensorFlow checkpoint in the PyTorch model and saves the resulting model in a standard PyTorch save file that can be imported using torch.load() (see examples in extract_features.py, run_classifier.py and run_squad.py). \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8617681886753712
      ],
      "excerpt": "Here is an example of the conversion process for a pre-trained OpenAI GPT model, assuming that your NumPy checkpoint save as the same format than OpenAI pretrained model (see here) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8126041616015847
      ],
      "excerpt": "The original TensorFlow code further comprises two scripts for pre-training BERT: create_pretraining_data.py and run_pretraining.py. \n",
      "technique": "Supervised classification"
    }
  ],
  "issueTracker": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/cedrickchee/pytorch-pretrained-BERT/issues{/number}",
    "technique": "GitHub API"
  },
  "languages": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "Jupyter Notebook",
      "Python",
      "Dockerfile"
    ],
    "technique": "GitHub API"
  },
  "license": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "name": "Apache License 2.0",
      "url": "https://api.github.com/licenses/apache-2.0"
    },
    "technique": "GitHub API"
  },
  "licenseText": {
    "confidence": [
      1.0
    ],
    "excerpt": "b'\\n                                 Apache License\\n                           Version 2.0, January 2004\\n                        http://www.apache.org/licenses/\\n\\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\\n\\n   1. Definitions.\\n\\n      \"License\" shall mean the terms and conditions for use, reproduction,\\n      and distribution as defined by Sections 1 through 9 of this document.\\n\\n      \"Licensor\" shall mean the copyright owner or entity authorized by\\n      the copyright owner that is granting the License.\\n\\n      \"Legal Entity\" shall mean the union of the acting entity and all\\n      other entities that control, are controlled by, or are under common\\n      control with that entity. For the purposes of this definition,\\n      \"control\" means (i) the power, direct or indirect, to cause the\\n      direction or management of such entity, whether by contract or\\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\\n      outstanding shares, or (iii) beneficial ownership of such entity.\\n\\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\\n      exercising permissions granted by this License.\\n\\n      \"Source\" form shall mean the preferred form for making modifications,\\n      including but not limited to software source code, documentation\\n      source, and configuration files.\\n\\n      \"Object\" form shall mean any form resulting from mechanical\\n      transformation or translation of a Source form, including but\\n      not limited to compiled object code, generated documentation,\\n      and conversions to other media types.\\n\\n      \"Work\" shall mean the work of authorship, whether in Source or\\n      Object form, made available under the License, as indicated by a\\n      copyright notice that is included in or attached to the work\\n      (an example is provided in the Appendix below).\\n\\n      \"Derivative Works\" shall mean any work, whether in Source or Object\\n      form, that is based on (or derived from) the Work and for which the\\n      editorial revisions, annotations, elaborations, or other modifications\\n      represent, as a whole, an original work of authorship. For the purposes\\n      of this License, Derivative Works shall not include works that remain\\n      separable from, or merely link (or bind by name) to the interfaces of,\\n      the Work and Derivative Works thereof.\\n\\n      \"Contribution\" shall mean any work of authorship, including\\n      the original version of the Work and any modifications or additions\\n      to that Work or Derivative Works thereof, that is intentionally\\n      submitted to Licensor for inclusion in the Work by the copyright owner\\n      or by an individual or Legal Entity authorized to submit on behalf of\\n      the copyright owner. For the purposes of this definition, \"submitted\"\\n      means any form of electronic, verbal, or written communication sent\\n      to the Licensor or its representatives, including but not limited to\\n      communication on electronic mailing lists, source code control systems,\\n      and issue tracking systems that are managed by, or on behalf of, the\\n      Licensor for the purpose of discussing and improving the Work, but\\n      excluding communication that is conspicuously marked or otherwise\\n      designated in writing by the copyright owner as \"Not a Contribution.\"\\n\\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\\n      on behalf of whom a Contribution has been received by Licensor and\\n      subsequently incorporated within the Work.\\n\\n   2. Grant of Copyright License. Subject to the terms and conditions of\\n      this License, each Contributor hereby grants to You a perpetual,\\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n      copyright license to reproduce, prepare Derivative Works of,\\n      publicly display, publicly perform, sublicense, and distribute the\\n      Work and such Derivative Works in Source or Object form.\\n\\n   3. Grant of Patent License. Subject to the terms and conditions of\\n      this License, each Contributor hereby grants to You a perpetual,\\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n      (except as stated in this section) patent license to make, have made,\\n      use, offer to sell, sell, import, and otherwise transfer the Work,\\n      where such license applies only to those patent claims licensable\\n      by such Contributor that are necessarily infringed by their\\n      Contribution(s) alone or by combination of their Contribution(s)\\n      with the Work to which such Contribution(s) was submitted. If You\\n      institute patent litigation against any entity (including a\\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\\n      or a Contribution incorporated within the Work constitutes direct\\n      or contributory patent infringement, then any patent licenses\\n      granted to You under this License for that Work shall terminate\\n      as of the date such litigation is filed.\\n\\n   4. Redistribution. You may reproduce and distribute copies of the\\n      Work or Derivative Works thereof in any medium, with or without\\n      modifications, and in Source or Object form, provided that You\\n      meet the following conditions:\\n\\n      (a) You must give any other recipients of the Work or\\n          Derivative Works a copy of this License; and\\n\\n      (b) You must cause any modified files to carry prominent notices\\n          stating that You changed the files; and\\n\\n      (c) You must retain, in the Source form of any Derivative Works\\n          that You distribute, all copyright, patent, trademark, and\\n          attribution notices from the Source form of the Work,\\n          excluding those notices that do not pertain to any part of\\n          the Derivative Works; and\\n\\n      (d) If the Work includes a \"NOTICE\" text file as part of its\\n          distribution, then any Derivative Works that You distribute must\\n          include a readable copy of the attribution notices contained\\n          within such NOTICE file, excluding those notices that do not\\n          pertain to any part of the Derivative Works, in at least one\\n          of the following places: within a NOTICE text file distributed\\n          as part of the Derivative Works; within the Source form or\\n          documentation, if provided along with the Derivative Works; or,\\n          within a display generated by the Derivative Works, if and\\n          wherever such third-party notices normally appear. The contents\\n          of the NOTICE file are for informational purposes only and\\n          do not modify the License. You may add Your own attribution\\n          notices within Derivative Works that You distribute, alongside\\n          or as an addendum to the NOTICE text from the Work, provided\\n          that such additional attribution notices cannot be construed\\n          as modifying the License.\\n\\n      You may add Your own copyright statement to Your modifications and\\n      may provide additional or different license terms and conditions\\n      for use, reproduction, or distribution of Your modifications, or\\n      for any such Derivative Works as a whole, provided Your use,\\n      reproduction, and distribution of the Work otherwise complies with\\n      the conditions stated in this License.\\n\\n   5. Submission of Contributions. Unless You explicitly state otherwise,\\n      any Contribution intentionally submitted for inclusion in the Work\\n      by You to the Licensor shall be under the terms and conditions of\\n      this License, without any additional terms or conditions.\\n      Notwithstanding the above, nothing herein shall supersede or modify\\n      the terms of any separate license agreement you may have executed\\n      with Licensor regarding such Contributions.\\n\\n   6. Trademarks. This License does not grant permission to use the trade\\n      names, trademarks, service marks, or product names of the Licensor,\\n      except as required for reasonable and customary use in describing the\\n      origin of the Work and reproducing the content of the NOTICE file.\\n\\n   7. Disclaimer of Warranty. Unless required by applicable law or\\n      agreed to in writing, Licensor provides the Work (and each\\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\\n      implied, including, without limitation, any warranties or conditions\\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\\n      PARTICULAR PURPOSE. You are solely responsible for determining the\\n      appropriateness of using or redistributing the Work and assume any\\n      risks associated with Your exercise of permissions under this License.\\n\\n   8. Limitation of Liability. In no event and under no legal theory,\\n      whether in tort (including negligence), contract, or otherwise,\\n      unless required by applicable law (such as deliberate and grossly\\n      negligent acts) or agreed to in writing, shall any Contributor be\\n      liable to You for damages, including any direct, indirect, special,\\n      incidental, or consequential damages of any character arising as a\\n      result of this License or out of the use or inability to use the\\n      Work (including but not limited to damages for loss of goodwill,\\n      work stoppage, computer failure or malfunction, or any and all\\n      other commercial damages or losses), even if such Contributor\\n      has been advised of the possibility of such damages.\\n\\n   9. Accepting Warranty or Additional Liability. While redistributing\\n      the Work or Derivative Works thereof, You may choose to offer,\\n      and charge a fee for, acceptance of support, warranty, indemnity,\\n      or other liability obligations and/or rights consistent with this\\n      License. However, in accepting such obligations, You may act only\\n      on Your own behalf and on Your sole responsibility, not on behalf\\n      of any other Contributor, and only if You agree to indemnify,\\n      defend, and hold each Contributor harmless for any liability\\n      incurred by, or claims asserted against, such Contributor by reason\\n      of your accepting any such warranty or additional liability.\\n\\n   END OF TERMS AND CONDITIONS\\n\\n   APPENDIX: How to apply the Apache License to your work.\\n\\n      To apply the Apache License to your work, attach the following\\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\\n      replaced with your own identifying information. (Don\\'t include\\n      the brackets!)  The text should be enclosed in the appropriate\\n      comment syntax for the file format. We also recommend that a\\n      file or class name and description of purpose be included on the\\n      same \"printed page\" as the copyright notice for easier\\n      identification within third-party archives.\\n\\n   Copyright [yyyy] [name of copyright owner]\\n\\n   Licensed under the Apache License, Version 2.0 (the \"License\");\\n   you may not use this file except in compliance with the License.\\n   You may obtain a copy of the License at\\n\\n       http://www.apache.org/licenses/LICENSE-2.0\\n\\n   Unless required by applicable law or agreed to in writing, software\\n   distributed under the License is distributed on an \"AS IS\" BASIS,\\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n   See the License for the specific language governing permissions and\\n   limitations under the License.\\n'",
    "technique": "File Exploration"
  },
  "long_title": {
    "confidence": [
      1.0
    ],
    "excerpt": "PyTorch Pretrained BERT: The Big & Extending Repository of pretrained Transformers",
    "technique": "Regular expression"
  },
  "name": {
    "confidence": [
      1.0
    ],
    "excerpt": "pytorch-pretrained-BERT",
    "technique": "GitHub API"
  },
  "owner": {
    "confidence": [
      1.0
    ],
    "excerpt": "cedrickchee",
    "technique": "GitHub API"
  },
  "ownerType": {
    "confidence": [
      1.0
    ],
    "excerpt": "User",
    "technique": "GitHub API"
  },
  "readme_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/cedrickchee/pytorch-pretrained-BERT/blob/master/README.md",
    "technique": "GitHub API"
  },
  "run": [
    {
      "confidence": [
        1
      ],
      "excerpt": "We showcase several fine-tuning examples based on (and extended from) [the original implementation](https://github.com/google-research/bert/):\n\n- a *sequence-level classifier* on nine different GLUE tasks,\n- a *token-level classifier* on the question answering dataset SQuAD, and\n- a *sequence-level multiple-choice classifier* on the SWAG classification corpus.\n- a *BERT language model* on another target corpus\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        1
      ],
      "excerpt": "We provide three examples of scripts for OpenAI GPT, Transformer-XL and OpenAI GPT-2 based on (and extended from) the respective original implementations:\n\n- fine-tuning OpenAI GPT on the ROCStories dataset\n- evaluating Transformer-XL on Wikitext 103\n- unconditional and conditional generation from a pre-trained OpenAI GPT-2 model\n\n",
      "technique": "Header extraction"
    }
  ],
  "stargazers_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 9,
      "date": "Thu, 23 Dec 2021 10:02:17 GMT"
    },
    "technique": "GitHub API"
  },
  "topics": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "nlp",
      "machine-learning-algorithms",
      "pytorch",
      "natural-language-understanding",
      "bidirectional",
      "transformers",
      "pretrained-models"
    ],
    "technique": "GitHub API"
  },
  "usage": [
    {
      "confidence": [
        1
      ],
      "excerpt": "| Sub-section | Description |\n|-|-|\n| [Training large models: introduction, tools and examples](#Training-large-models-introduction,-tools-and-examples) | How to use gradient-accumulation, multi-gpu training, distributed training, optimize on CPU and 16-bits training to train Bert models |\n| [Fine-tuning with BERT: running the examples](#Fine-tuning-with-BERT-running-the-examples) | Running the examples in [`./examples`](./examples/): `extract_classif.py`, `run_classifier.py`, `run_squad.py` and `run_lm_finetuning.py` |\n| [Fine-tuning with OpenAI GPT, Transformer-XL and GPT-2](#Fine-tuning-with-OpenAI-GPT-Transformer-XL-and-GPT-2) | Running the examples in [`./examples`](./examples/): `run_openai_gpt.py`, `run_transfo_xl.py` and `run_gpt2.py` |\n| [Fine-tuning BERT-large on GPUs](#Fine-tuning-BERT-large-on-GPUs) | How to fine tune `BERT large`|\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        1
      ],
      "excerpt": "BERT-base and BERT-large are respectively 110M and 340M parameters models and it can be difficult to fine-tune them on a single GPU with the recommended batch size for good performance (in most case a batch size of 32).\n\nTo help with fine-tuning these models, we have included several techniques that you can activate in the fine-tuning scripts [`run_classifier.py`](./examples/run_classifier.py) and [`run_squad.py`](./examples/run_squad.py): gradient-accumulation, multi-gpu training, distributed training and 16-bits training . For more details on how to use these techniques you can read [the tips on training large batches in PyTorch](https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255) that I published earlier this month.\n\nHere is how to use these techniques in our scripts:\n\n- **Gradient Accumulation**: Gradient accumulation can be used by supplying a integer greater than 1 to the `--gradient_accumulation_steps` argument. The batch at each step will be divided by this integer and gradient will be accumulated over `gradient_accumulation_steps` steps.\n- **Multi-GPU**: Multi-GPU is automatically activated when several GPUs are detected and the batches are splitted over the GPUs.\n- **Distributed training**: Distributed training can be activated by supplying an integer greater or equal to 0 to the `--local_rank` argument (see below).\n- **16-bits training**: 16-bits training, also called mixed-precision training, can reduce the memory requirement of your model on the GPU by using half-precision training, basically allowing to double the batch size. If you have a recent GPU (starting from NVIDIA Volta architecture) you should see no decrease in speed. A good introduction to Mixed precision training can be found [here](https://devblogs.nvidia.com/mixed-precision-training-deep-neural-networks/) and a full documentation is [here](https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html). In our scripts, this option can be activated by setting the `--fp16` flag and you can play with loss scaling using the `--loss_scale` flag (see the previously linked documentation for details on loss scaling). The loss scale can be zero in which case the scale is dynamically adjusted or a positive power of two in which case the scaling is static.\n\nTo use 16-bits training and distributed training, you need to install NVIDIA's apex extension [as detailed here](https://github.com/nvidia/apex). You will find more information regarding the internals of `apex` and how to use `apex` in [the doc and the associated repository](https://github.com/nvidia/apex). The results of the tests performed on pytorch-BERT by the NVIDIA team (and my trials at reproducing them) can be consulted in [the relevant PR of the present repository](https://github.com/huggingface/pytorch-pretrained-BERT/pull/116).\n\nNote: To use *Distributed Training*, you will need to run one training script on each of your machines. This can be done for example by running the following command on each server (see [the above mentioned blog post]((https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255)) for more details):\n```bash\npython -m torch.distributed.launch --nproc_per_node=4 --nnodes=2 --node_rank=$THIS_MACHINE_INDEX --master_addr=\"192.168.1.1\" --master_port=1234 run_classifier.py (--arg1 --arg2 --arg3 and all other arguments of the run_classifier script)\n```\nWhere `$THIS_MACHINE_INDEX` is an sequential index assigned to each of your machine (0, 1, 2...) and the machine with rank 0 has an IP address `192.168.1.1` and an open port `1234`.\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        1
      ],
      "excerpt": "We showcase several fine-tuning examples based on (and extended from) [the original implementation](https://github.com/google-research/bert/):\n\n- a *sequence-level classifier* on nine different GLUE tasks,\n- a *token-level classifier* on the question answering dataset SQuAD, and\n- a *sequence-level multiple-choice classifier* on the SWAG classification corpus.\n- a *BERT language model* on another target corpus\n\n",
      "technique": "Header extraction"
    },
    {
      "confidence": [
        1
      ],
      "excerpt": "We provide three examples of scripts for OpenAI GPT, Transformer-XL and OpenAI GPT-2 based on (and extended from) the respective original implementations:\n\n- fine-tuning OpenAI GPT on the ROCStories dataset\n- evaluating Transformer-XL on Wikitext 103\n- unconditional and conditional generation from a pre-trained OpenAI GPT-2 model\n\n",
      "technique": "Header extraction"
    }
  ]
}