{
  "codeRepository": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/gnouhp/PyTorch-CoordConv",
    "technique": "GitHub API"
  },
  "dateCreated": {
    "confidence": [
      1.0
    ],
    "excerpt": "2018-08-31T05:37:01Z",
    "technique": "GitHub API"
  },
  "dateModified": {
    "confidence": [
      1.0
    ],
    "excerpt": "2019-07-10T01:31:01Z",
    "technique": "GitHub API"
  },
  "description": [
    {
      "confidence": [
        0.8787366421941792,
        0.9077776791661175,
        0.9348655957431253
      ],
      "excerpt": "Unofficial CoordConv nn.Module implementation and using it for supervised regression on the Not-so_Clevr dataset. \nFor more information, check out Uber's blog and paper on arxiv. \nAs described in the research paper, the Not-so-Clevr dataset can be generated in 2 lines of code with tensorflow and numpy as show below: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9328924286722866
      ],
      "excerpt": "I replicated the data generation in PyTorch, which requires more lines but is likewise just as simple, as such: \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8979411005071259,
        0.8979411005071259
      ],
      "excerpt": "      conv.weight.data.fill_(1) \n      conv.bias.data.fill_(0) \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.9777093234814841
      ],
      "excerpt": "Convolution is an equivariant operation, meaning that the model doesn't have a means to know where in a feature map that filters are activating. CoordConv fixes this problem by concatenating two channels that add spatial information to images. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8637157508443228,
        0.9802412574321278
      ],
      "excerpt": "In cases where equivariance is actually helpful, CoordConv layers still don't hurt model performance, because filter weights over the spatial channels can become zero. \nIn the supervised regression task, the input is a 1-dimensional image array, and the model trains to predict the coordinates of the top-left corner of the square in the image. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8756974897190887
      ],
      "excerpt": "In multiple attempts, I wasn't able to get significantly better performance with a small network with a CoordConv module as the first layer. In the papers, the authors use a network with a few more layers and a global pooling layer instead of the fully-connected layers I use, so I would be interested in whether or not the CoordConv and global pooling layers have a unique relationship. \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        1.0
      ],
      "excerpt": "CoordConv and Not-so-Clevr dataset generation implementations in PyTorch",
      "technique": "GitHub API"
    }
  ],
  "downloadUrl": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/gnouhp/PyTorch-CoordConv/releases",
    "technique": "GitHub API"
  },
  "forks_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 0,
      "date": "Sat, 25 Dec 2021 02:11:34 GMT"
    },
    "technique": "GitHub API"
  },
  "forks_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/gnouhp/PyTorch-CoordConv/forks",
    "technique": "GitHub API"
  },
  "fullName": {
    "confidence": [
      1.0
    ],
    "excerpt": "gnouhp/PyTorch-CoordConv",
    "technique": "GitHub API"
  },
  "invocation": [
    {
      "confidence": [
        0.8819742228320124,
        0.8881064279337868
      ],
      "excerpt": "onehots = np.pad(np.eye(3136).reshape((3136, 56, 56, 1)), ((0,0), (4,4), (4,4), (0,0)), \"constant\"); \nimages = tf.nn.conv2d(onehots, np.ones((9, 9, 1, 1)), [1]*4, \"SAME\") \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8819742228320124
      ],
      "excerpt": "  onehots = np.pad(np.eye(n_samples).reshape((n_samples, 1, 56, 56)), ((0,0), (0, 0), (4,4), (4,4)), \"constant\") \n",
      "technique": "Supervised classification"
    },
    {
      "confidence": [
        0.8711681737126942
      ],
      "excerpt": "Example input: \n",
      "technique": "Supervised classification"
    }
  ],
  "issueTracker": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://api.github.com/repos/gnouhp/PyTorch-CoordConv/issues{/number}",
    "technique": "GitHub API"
  },
  "languages": {
    "confidence": [
      1.0
    ],
    "excerpt": [
      "Python"
    ],
    "technique": "GitHub API"
  },
  "license": {
    "confidence": [
      1.0
    ],
    "technique": "GitHub API"
  },
  "long_title": {
    "confidence": [
      1.0
    ],
    "excerpt": "PyTorch-CoordConv",
    "technique": "Regular expression"
  },
  "name": {
    "confidence": [
      1.0
    ],
    "excerpt": "PyTorch-CoordConv",
    "technique": "GitHub API"
  },
  "owner": {
    "confidence": [
      1.0
    ],
    "excerpt": "gnouhp",
    "technique": "GitHub API"
  },
  "ownerType": {
    "confidence": [
      1.0
    ],
    "excerpt": "User",
    "technique": "GitHub API"
  },
  "readme_url": {
    "confidence": [
      1.0
    ],
    "excerpt": "https://github.com/gnouhp/PyTorch-CoordConv/blob/master/README.md",
    "technique": "GitHub API"
  },
  "stargazers_count": {
    "confidence": [
      1.0
    ],
    "excerpt": {
      "count": 1,
      "date": "Sat, 25 Dec 2021 02:11:34 GMT"
    },
    "technique": "GitHub API"
  }
}